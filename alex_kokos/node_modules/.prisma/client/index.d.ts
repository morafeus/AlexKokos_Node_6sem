
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Answers
 * 
 */
export type Answers = $Result.DefaultSelection<Prisma.$AnswersPayload>
/**
 * Model Courses
 * 
 */
export type Courses = $Result.DefaultSelection<Prisma.$CoursesPayload>
/**
 * Model Desciplines
 * 
 */
export type Desciplines = $Result.DefaultSelection<Prisma.$DesciplinesPayload>
/**
 * Model Materials
 * 
 */
export type Materials = $Result.DefaultSelection<Prisma.$MaterialsPayload>
/**
 * Model Students
 * 
 */
export type Students = $Result.DefaultSelection<Prisma.$StudentsPayload>
/**
 * Model StudentToCourse
 * 
 */
export type StudentToCourse = $Result.DefaultSelection<Prisma.$StudentToCoursePayload>
/**
 * Model Teachers
 * 
 */
export type Teachers = $Result.DefaultSelection<Prisma.$TeachersPayload>
/**
 * Model TeacherToCourse
 * 
 */
export type TeacherToCourse = $Result.DefaultSelection<Prisma.$TeacherToCoursePayload>
/**
 * Model Tests
 * 
 */
export type Tests = $Result.DefaultSelection<Prisma.$TestsPayload>
/**
 * Model TestStatus
 * 
 */
export type TestStatus = $Result.DefaultSelection<Prisma.$TestStatusPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Answers
 * const answers = await prisma.answers.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Answers
   * const answers = await prisma.answers.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.answers`: Exposes CRUD operations for the **Answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answers.findMany()
    * ```
    */
  get answers(): Prisma.AnswersDelegate<ExtArgs>;

  /**
   * `prisma.courses`: Exposes CRUD operations for the **Courses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.courses.findMany()
    * ```
    */
  get courses(): Prisma.CoursesDelegate<ExtArgs>;

  /**
   * `prisma.desciplines`: Exposes CRUD operations for the **Desciplines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Desciplines
    * const desciplines = await prisma.desciplines.findMany()
    * ```
    */
  get desciplines(): Prisma.DesciplinesDelegate<ExtArgs>;

  /**
   * `prisma.materials`: Exposes CRUD operations for the **Materials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.materials.findMany()
    * ```
    */
  get materials(): Prisma.MaterialsDelegate<ExtArgs>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **Students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.StudentsDelegate<ExtArgs>;

  /**
   * `prisma.studentToCourse`: Exposes CRUD operations for the **StudentToCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentToCourses
    * const studentToCourses = await prisma.studentToCourse.findMany()
    * ```
    */
  get studentToCourse(): Prisma.StudentToCourseDelegate<ExtArgs>;

  /**
   * `prisma.teachers`: Exposes CRUD operations for the **Teachers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teachers.findMany()
    * ```
    */
  get teachers(): Prisma.TeachersDelegate<ExtArgs>;

  /**
   * `prisma.teacherToCourse`: Exposes CRUD operations for the **TeacherToCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherToCourses
    * const teacherToCourses = await prisma.teacherToCourse.findMany()
    * ```
    */
  get teacherToCourse(): Prisma.TeacherToCourseDelegate<ExtArgs>;

  /**
   * `prisma.tests`: Exposes CRUD operations for the **Tests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tests
    * const tests = await prisma.tests.findMany()
    * ```
    */
  get tests(): Prisma.TestsDelegate<ExtArgs>;

  /**
   * `prisma.testStatus`: Exposes CRUD operations for the **TestStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestStatuses
    * const testStatuses = await prisma.testStatus.findMany()
    * ```
    */
  get testStatus(): Prisma.TestStatusDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Answers: 'Answers',
    Courses: 'Courses',
    Desciplines: 'Desciplines',
    Materials: 'Materials',
    Students: 'Students',
    StudentToCourse: 'StudentToCourse',
    Teachers: 'Teachers',
    TeacherToCourse: 'TeacherToCourse',
    Tests: 'Tests',
    TestStatus: 'TestStatus'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'answers' | 'courses' | 'desciplines' | 'materials' | 'students' | 'studentToCourse' | 'teachers' | 'teacherToCourse' | 'tests' | 'testStatus'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Answers: {
        payload: Prisma.$AnswersPayload<ExtArgs>
        fields: Prisma.AnswersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          findFirst: {
            args: Prisma.AnswersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          findMany: {
            args: Prisma.AnswersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>[]
          }
          create: {
            args: Prisma.AnswersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          createMany: {
            args: Prisma.AnswersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AnswersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          update: {
            args: Prisma.AnswersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          deleteMany: {
            args: Prisma.AnswersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnswersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnswersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswersPayload>
          }
          aggregate: {
            args: Prisma.AnswersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnswers>
          }
          groupBy: {
            args: Prisma.AnswersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnswersGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswersCountArgs<ExtArgs>,
            result: $Utils.Optional<AnswersCountAggregateOutputType> | number
          }
        }
      }
      Courses: {
        payload: Prisma.$CoursesPayload<ExtArgs>
        fields: Prisma.CoursesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoursesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoursesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          findFirst: {
            args: Prisma.CoursesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoursesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          findMany: {
            args: Prisma.CoursesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>[]
          }
          create: {
            args: Prisma.CoursesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          createMany: {
            args: Prisma.CoursesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CoursesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          update: {
            args: Prisma.CoursesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          deleteMany: {
            args: Prisma.CoursesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CoursesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CoursesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CoursesPayload>
          }
          aggregate: {
            args: Prisma.CoursesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourses>
          }
          groupBy: {
            args: Prisma.CoursesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CoursesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoursesCountArgs<ExtArgs>,
            result: $Utils.Optional<CoursesCountAggregateOutputType> | number
          }
        }
      }
      Desciplines: {
        payload: Prisma.$DesciplinesPayload<ExtArgs>
        fields: Prisma.DesciplinesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DesciplinesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DesciplinesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DesciplinesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DesciplinesPayload>
          }
          findFirst: {
            args: Prisma.DesciplinesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DesciplinesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DesciplinesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DesciplinesPayload>
          }
          findMany: {
            args: Prisma.DesciplinesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DesciplinesPayload>[]
          }
          create: {
            args: Prisma.DesciplinesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DesciplinesPayload>
          }
          createMany: {
            args: Prisma.DesciplinesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DesciplinesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DesciplinesPayload>
          }
          update: {
            args: Prisma.DesciplinesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DesciplinesPayload>
          }
          deleteMany: {
            args: Prisma.DesciplinesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DesciplinesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DesciplinesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DesciplinesPayload>
          }
          aggregate: {
            args: Prisma.DesciplinesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDesciplines>
          }
          groupBy: {
            args: Prisma.DesciplinesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DesciplinesGroupByOutputType>[]
          }
          count: {
            args: Prisma.DesciplinesCountArgs<ExtArgs>,
            result: $Utils.Optional<DesciplinesCountAggregateOutputType> | number
          }
        }
      }
      Materials: {
        payload: Prisma.$MaterialsPayload<ExtArgs>
        fields: Prisma.MaterialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          findFirst: {
            args: Prisma.MaterialsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          findMany: {
            args: Prisma.MaterialsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>[]
          }
          create: {
            args: Prisma.MaterialsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          createMany: {
            args: Prisma.MaterialsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MaterialsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          update: {
            args: Prisma.MaterialsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          deleteMany: {
            args: Prisma.MaterialsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MaterialsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MaterialsPayload>
          }
          aggregate: {
            args: Prisma.MaterialsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMaterials>
          }
          groupBy: {
            args: Prisma.MaterialsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MaterialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialsCountArgs<ExtArgs>,
            result: $Utils.Optional<MaterialsCountAggregateOutputType> | number
          }
        }
      }
      Students: {
        payload: Prisma.$StudentsPayload<ExtArgs>
        fields: Prisma.StudentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          findFirst: {
            args: Prisma.StudentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          findMany: {
            args: Prisma.StudentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>[]
          }
          create: {
            args: Prisma.StudentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          createMany: {
            args: Prisma.StudentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          update: {
            args: Prisma.StudentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          deleteMany: {
            args: Prisma.StudentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.StudentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentsCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
      StudentToCourse: {
        payload: Prisma.$StudentToCoursePayload<ExtArgs>
        fields: Prisma.StudentToCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentToCourseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentToCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentToCourseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentToCoursePayload>
          }
          findFirst: {
            args: Prisma.StudentToCourseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentToCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentToCourseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentToCoursePayload>
          }
          findMany: {
            args: Prisma.StudentToCourseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentToCoursePayload>[]
          }
          create: {
            args: Prisma.StudentToCourseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentToCoursePayload>
          }
          createMany: {
            args: Prisma.StudentToCourseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StudentToCourseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentToCoursePayload>
          }
          update: {
            args: Prisma.StudentToCourseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentToCoursePayload>
          }
          deleteMany: {
            args: Prisma.StudentToCourseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StudentToCourseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StudentToCourseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StudentToCoursePayload>
          }
          aggregate: {
            args: Prisma.StudentToCourseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentToCourse>
          }
          groupBy: {
            args: Prisma.StudentToCourseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentToCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentToCourseCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentToCourseCountAggregateOutputType> | number
          }
        }
      }
      Teachers: {
        payload: Prisma.$TeachersPayload<ExtArgs>
        fields: Prisma.TeachersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeachersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeachersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          findFirst: {
            args: Prisma.TeachersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeachersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          findMany: {
            args: Prisma.TeachersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>[]
          }
          create: {
            args: Prisma.TeachersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          createMany: {
            args: Prisma.TeachersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeachersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          update: {
            args: Prisma.TeachersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          deleteMany: {
            args: Prisma.TeachersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeachersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeachersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeachersPayload>
          }
          aggregate: {
            args: Prisma.TeachersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeachers>
          }
          groupBy: {
            args: Prisma.TeachersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeachersGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeachersCountArgs<ExtArgs>,
            result: $Utils.Optional<TeachersCountAggregateOutputType> | number
          }
        }
      }
      TeacherToCourse: {
        payload: Prisma.$TeacherToCoursePayload<ExtArgs>
        fields: Prisma.TeacherToCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherToCourseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherToCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherToCourseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherToCoursePayload>
          }
          findFirst: {
            args: Prisma.TeacherToCourseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherToCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherToCourseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherToCoursePayload>
          }
          findMany: {
            args: Prisma.TeacherToCourseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherToCoursePayload>[]
          }
          create: {
            args: Prisma.TeacherToCourseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherToCoursePayload>
          }
          createMany: {
            args: Prisma.TeacherToCourseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeacherToCourseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherToCoursePayload>
          }
          update: {
            args: Prisma.TeacherToCourseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherToCoursePayload>
          }
          deleteMany: {
            args: Prisma.TeacherToCourseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherToCourseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeacherToCourseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeacherToCoursePayload>
          }
          aggregate: {
            args: Prisma.TeacherToCourseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeacherToCourse>
          }
          groupBy: {
            args: Prisma.TeacherToCourseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeacherToCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherToCourseCountArgs<ExtArgs>,
            result: $Utils.Optional<TeacherToCourseCountAggregateOutputType> | number
          }
        }
      }
      Tests: {
        payload: Prisma.$TestsPayload<ExtArgs>
        fields: Prisma.TestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestsPayload>
          }
          findFirst: {
            args: Prisma.TestsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestsPayload>
          }
          findMany: {
            args: Prisma.TestsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestsPayload>[]
          }
          create: {
            args: Prisma.TestsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestsPayload>
          }
          createMany: {
            args: Prisma.TestsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TestsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestsPayload>
          }
          update: {
            args: Prisma.TestsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestsPayload>
          }
          deleteMany: {
            args: Prisma.TestsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TestsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TestsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestsPayload>
          }
          aggregate: {
            args: Prisma.TestsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTests>
          }
          groupBy: {
            args: Prisma.TestsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestsCountArgs<ExtArgs>,
            result: $Utils.Optional<TestsCountAggregateOutputType> | number
          }
        }
      }
      TestStatus: {
        payload: Prisma.$TestStatusPayload<ExtArgs>
        fields: Prisma.TestStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestStatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestStatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestStatusPayload>
          }
          findFirst: {
            args: Prisma.TestStatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestStatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestStatusPayload>
          }
          findMany: {
            args: Prisma.TestStatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestStatusPayload>[]
          }
          create: {
            args: Prisma.TestStatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestStatusPayload>
          }
          createMany: {
            args: Prisma.TestStatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TestStatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestStatusPayload>
          }
          update: {
            args: Prisma.TestStatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestStatusPayload>
          }
          deleteMany: {
            args: Prisma.TestStatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TestStatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TestStatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TestStatusPayload>
          }
          aggregate: {
            args: Prisma.TestStatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTestStatus>
          }
          groupBy: {
            args: Prisma.TestStatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TestStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestStatusCountArgs<ExtArgs>,
            result: $Utils.Optional<TestStatusCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CoursesCountOutputType
   */

  export type CoursesCountOutputType = {
    Materials: number
    StudentToCourse: number
    TeacherToCourse: number
    Tests: number
  }

  export type CoursesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Materials?: boolean | CoursesCountOutputTypeCountMaterialsArgs
    StudentToCourse?: boolean | CoursesCountOutputTypeCountStudentToCourseArgs
    TeacherToCourse?: boolean | CoursesCountOutputTypeCountTeacherToCourseArgs
    Tests?: boolean | CoursesCountOutputTypeCountTestsArgs
  }

  // Custom InputTypes

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursesCountOutputType
     */
    select?: CoursesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialsWhereInput
  }


  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountStudentToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentToCourseWhereInput
  }


  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountTeacherToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherToCourseWhereInput
  }


  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestsWhereInput
  }



  /**
   * Count Type DesciplinesCountOutputType
   */

  export type DesciplinesCountOutputType = {
    Courses: number
    Teachers: number
  }

  export type DesciplinesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | DesciplinesCountOutputTypeCountCoursesArgs
    Teachers?: boolean | DesciplinesCountOutputTypeCountTeachersArgs
  }

  // Custom InputTypes

  /**
   * DesciplinesCountOutputType without action
   */
  export type DesciplinesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DesciplinesCountOutputType
     */
    select?: DesciplinesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DesciplinesCountOutputType without action
   */
  export type DesciplinesCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursesWhereInput
  }


  /**
   * DesciplinesCountOutputType without action
   */
  export type DesciplinesCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachersWhereInput
  }



  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    StudentToCourse: number
    TestStatus: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    StudentToCourse?: boolean | StudentsCountOutputTypeCountStudentToCourseArgs
    TestStatus?: boolean | StudentsCountOutputTypeCountTestStatusArgs
  }

  // Custom InputTypes

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudentToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentToCourseWhereInput
  }


  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountTestStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestStatusWhereInput
  }



  /**
   * Count Type TeachersCountOutputType
   */

  export type TeachersCountOutputType = {
    TeacherToCourse: number
  }

  export type TeachersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TeacherToCourse?: boolean | TeachersCountOutputTypeCountTeacherToCourseArgs
  }

  // Custom InputTypes

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachersCountOutputType
     */
    select?: TeachersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountTeacherToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherToCourseWhereInput
  }



  /**
   * Count Type TestsCountOutputType
   */

  export type TestsCountOutputType = {
    Answers: number
    TestStatus: number
  }

  export type TestsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Answers?: boolean | TestsCountOutputTypeCountAnswersArgs
    TestStatus?: boolean | TestsCountOutputTypeCountTestStatusArgs
  }

  // Custom InputTypes

  /**
   * TestsCountOutputType without action
   */
  export type TestsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestsCountOutputType
     */
    select?: TestsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TestsCountOutputType without action
   */
  export type TestsCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswersWhereInput
  }


  /**
   * TestsCountOutputType without action
   */
  export type TestsCountOutputTypeCountTestStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestStatusWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Answers
   */

  export type AggregateAnswers = {
    _count: AnswersCountAggregateOutputType | null
    _avg: AnswersAvgAggregateOutputType | null
    _sum: AnswersSumAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  export type AnswersAvgAggregateOutputType = {
    answer_id: number | null
    answer_count: number | null
    answer_right: number | null
    test_id: number | null
  }

  export type AnswersSumAggregateOutputType = {
    answer_id: number | null
    answer_count: number | null
    answer_right: number | null
    test_id: number | null
  }

  export type AnswersMinAggregateOutputType = {
    answer_id: number | null
    question: string | null
    answers: string | null
    answer_count: number | null
    answer_right: number | null
    test_id: number | null
  }

  export type AnswersMaxAggregateOutputType = {
    answer_id: number | null
    question: string | null
    answers: string | null
    answer_count: number | null
    answer_right: number | null
    test_id: number | null
  }

  export type AnswersCountAggregateOutputType = {
    answer_id: number
    question: number
    answers: number
    answer_count: number
    answer_right: number
    test_id: number
    _all: number
  }


  export type AnswersAvgAggregateInputType = {
    answer_id?: true
    answer_count?: true
    answer_right?: true
    test_id?: true
  }

  export type AnswersSumAggregateInputType = {
    answer_id?: true
    answer_count?: true
    answer_right?: true
    test_id?: true
  }

  export type AnswersMinAggregateInputType = {
    answer_id?: true
    question?: true
    answers?: true
    answer_count?: true
    answer_right?: true
    test_id?: true
  }

  export type AnswersMaxAggregateInputType = {
    answer_id?: true
    question?: true
    answers?: true
    answer_count?: true
    answer_right?: true
    test_id?: true
  }

  export type AnswersCountAggregateInputType = {
    answer_id?: true
    question?: true
    answers?: true
    answer_count?: true
    answer_right?: true
    test_id?: true
    _all?: true
  }

  export type AnswersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to aggregate.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswersMaxAggregateInputType
  }

  export type GetAnswersAggregateType<T extends AnswersAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswers[P]>
      : GetScalarType<T[P], AggregateAnswers[P]>
  }




  export type AnswersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswersWhereInput
    orderBy?: AnswersOrderByWithAggregationInput | AnswersOrderByWithAggregationInput[]
    by: AnswersScalarFieldEnum[] | AnswersScalarFieldEnum
    having?: AnswersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswersCountAggregateInputType | true
    _avg?: AnswersAvgAggregateInputType
    _sum?: AnswersSumAggregateInputType
    _min?: AnswersMinAggregateInputType
    _max?: AnswersMaxAggregateInputType
  }

  export type AnswersGroupByOutputType = {
    answer_id: number
    question: string
    answers: string
    answer_count: number
    answer_right: number
    test_id: number
    _count: AnswersCountAggregateOutputType | null
    _avg: AnswersAvgAggregateOutputType | null
    _sum: AnswersSumAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  type GetAnswersGroupByPayload<T extends AnswersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswersGroupByOutputType[P]>
            : GetScalarType<T[P], AnswersGroupByOutputType[P]>
        }
      >
    >


  export type AnswersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    answer_id?: boolean
    question?: boolean
    answers?: boolean
    answer_count?: boolean
    answer_right?: boolean
    test_id?: boolean
    Tests?: boolean | TestsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>

  export type AnswersSelectScalar = {
    answer_id?: boolean
    question?: boolean
    answers?: boolean
    answer_count?: boolean
    answer_right?: boolean
    test_id?: boolean
  }

  export type AnswersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tests?: boolean | TestsDefaultArgs<ExtArgs>
  }


  export type $AnswersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answers"
    objects: {
      Tests: Prisma.$TestsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      answer_id: number
      question: string
      answers: string
      answer_count: number
      answer_right: number
      test_id: number
    }, ExtArgs["result"]["answers"]>
    composites: {}
  }


  type AnswersGetPayload<S extends boolean | null | undefined | AnswersDefaultArgs> = $Result.GetResult<Prisma.$AnswersPayload, S>

  type AnswersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnswersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnswersCountAggregateInputType | true
    }

  export interface AnswersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answers'], meta: { name: 'Answers' } }
    /**
     * Find zero or one Answers that matches the filter.
     * @param {AnswersFindUniqueArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnswersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AnswersFindUniqueArgs<ExtArgs>>
    ): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Answers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnswersFindUniqueOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnswersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersFindFirstArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnswersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswersFindFirstArgs<ExtArgs>>
    ): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersFindFirstOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnswersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answers.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answers.findMany({ take: 10 })
     * 
     * // Only select the `answer_id`
     * const answersWithAnswer_idOnly = await prisma.answers.findMany({ select: { answer_id: true } })
     * 
    **/
    findMany<T extends AnswersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Answers.
     * @param {AnswersCreateArgs} args - Arguments to create a Answers.
     * @example
     * // Create one Answers
     * const Answers = await prisma.answers.create({
     *   data: {
     *     // ... data to create a Answers
     *   }
     * })
     * 
    **/
    create<T extends AnswersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnswersCreateArgs<ExtArgs>>
    ): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Answers.
     *     @param {AnswersCreateManyArgs} args - Arguments to create many Answers.
     *     @example
     *     // Create many Answers
     *     const answers = await prisma.answers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnswersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Answers.
     * @param {AnswersDeleteArgs} args - Arguments to delete one Answers.
     * @example
     * // Delete one Answers
     * const Answers = await prisma.answers.delete({
     *   where: {
     *     // ... filter to delete one Answers
     *   }
     * })
     * 
    **/
    delete<T extends AnswersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnswersDeleteArgs<ExtArgs>>
    ): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Answers.
     * @param {AnswersUpdateArgs} args - Arguments to update one Answers.
     * @example
     * // Update one Answers
     * const answers = await prisma.answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnswersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnswersUpdateArgs<ExtArgs>>
    ): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Answers.
     * @param {AnswersDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnswersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answers = await prisma.answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnswersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnswersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Answers.
     * @param {AnswersUpsertArgs} args - Arguments to update or create a Answers.
     * @example
     * // Update or create a Answers
     * const answers = await prisma.answers.upsert({
     *   create: {
     *     // ... data to create a Answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answers we want to update
     *   }
     * })
    **/
    upsert<T extends AnswersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnswersUpsertArgs<ExtArgs>>
    ): Prisma__AnswersClient<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answers.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswersCountArgs>(
      args?: Subset<T, AnswersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswersAggregateArgs>(args: Subset<T, AnswersAggregateArgs>): Prisma.PrismaPromise<GetAnswersAggregateType<T>>

    /**
     * Group by Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswersGroupByArgs['orderBy'] }
        : { orderBy?: AnswersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answers model
   */
  readonly fields: AnswersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Tests<T extends TestsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestsDefaultArgs<ExtArgs>>): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Answers model
   */ 
  interface AnswersFieldRefs {
    readonly answer_id: FieldRef<"Answers", 'Int'>
    readonly question: FieldRef<"Answers", 'String'>
    readonly answers: FieldRef<"Answers", 'String'>
    readonly answer_count: FieldRef<"Answers", 'Int'>
    readonly answer_right: FieldRef<"Answers", 'Int'>
    readonly test_id: FieldRef<"Answers", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Answers findUnique
   */
  export type AnswersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where: AnswersWhereUniqueInput
  }


  /**
   * Answers findUniqueOrThrow
   */
  export type AnswersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where: AnswersWhereUniqueInput
  }


  /**
   * Answers findFirst
   */
  export type AnswersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }


  /**
   * Answers findFirstOrThrow
   */
  export type AnswersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }


  /**
   * Answers findMany
   */
  export type AnswersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     */
    cursor?: AnswersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }


  /**
   * Answers create
   */
  export type AnswersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * The data needed to create a Answers.
     */
    data: XOR<AnswersCreateInput, AnswersUncheckedCreateInput>
  }


  /**
   * Answers createMany
   */
  export type AnswersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answers.
     */
    data: AnswersCreateManyInput | AnswersCreateManyInput[]
  }


  /**
   * Answers update
   */
  export type AnswersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * The data needed to update a Answers.
     */
    data: XOR<AnswersUpdateInput, AnswersUncheckedUpdateInput>
    /**
     * Choose, which Answers to update.
     */
    where: AnswersWhereUniqueInput
  }


  /**
   * Answers updateMany
   */
  export type AnswersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswersUpdateManyMutationInput, AnswersUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswersWhereInput
  }


  /**
   * Answers upsert
   */
  export type AnswersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * The filter to search for the Answers to update in case it exists.
     */
    where: AnswersWhereUniqueInput
    /**
     * In case the Answers found by the `where` argument doesn't exist, create a new Answers with this data.
     */
    create: XOR<AnswersCreateInput, AnswersUncheckedCreateInput>
    /**
     * In case the Answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswersUpdateInput, AnswersUncheckedUpdateInput>
  }


  /**
   * Answers delete
   */
  export type AnswersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    /**
     * Filter which Answers to delete.
     */
    where: AnswersWhereUniqueInput
  }


  /**
   * Answers deleteMany
   */
  export type AnswersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswersWhereInput
  }


  /**
   * Answers without action
   */
  export type AnswersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
  }



  /**
   * Model Courses
   */

  export type AggregateCourses = {
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  export type CoursesAvgAggregateOutputType = {
    course_id: number | null
    course_cost: number | null
  }

  export type CoursesSumAggregateOutputType = {
    course_id: number | null
    course_cost: number | null
  }

  export type CoursesMinAggregateOutputType = {
    course_id: number | null
    course_name: string | null
    course_cost: number | null
    course_description: string | null
    course_descipline: string | null
  }

  export type CoursesMaxAggregateOutputType = {
    course_id: number | null
    course_name: string | null
    course_cost: number | null
    course_description: string | null
    course_descipline: string | null
  }

  export type CoursesCountAggregateOutputType = {
    course_id: number
    course_name: number
    course_cost: number
    course_description: number
    course_descipline: number
    _all: number
  }


  export type CoursesAvgAggregateInputType = {
    course_id?: true
    course_cost?: true
  }

  export type CoursesSumAggregateInputType = {
    course_id?: true
    course_cost?: true
  }

  export type CoursesMinAggregateInputType = {
    course_id?: true
    course_name?: true
    course_cost?: true
    course_description?: true
    course_descipline?: true
  }

  export type CoursesMaxAggregateInputType = {
    course_id?: true
    course_name?: true
    course_cost?: true
    course_description?: true
    course_descipline?: true
  }

  export type CoursesCountAggregateInputType = {
    course_id?: true
    course_name?: true
    course_cost?: true
    course_description?: true
    course_descipline?: true
    _all?: true
  }

  export type CoursesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to aggregate.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CoursesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoursesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoursesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursesMaxAggregateInputType
  }

  export type GetCoursesAggregateType<T extends CoursesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourses[P]>
      : GetScalarType<T[P], AggregateCourses[P]>
  }




  export type CoursesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursesWhereInput
    orderBy?: CoursesOrderByWithAggregationInput | CoursesOrderByWithAggregationInput[]
    by: CoursesScalarFieldEnum[] | CoursesScalarFieldEnum
    having?: CoursesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursesCountAggregateInputType | true
    _avg?: CoursesAvgAggregateInputType
    _sum?: CoursesSumAggregateInputType
    _min?: CoursesMinAggregateInputType
    _max?: CoursesMaxAggregateInputType
  }

  export type CoursesGroupByOutputType = {
    course_id: number
    course_name: string
    course_cost: number
    course_description: string | null
    course_descipline: string
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  type GetCoursesGroupByPayload<T extends CoursesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursesGroupByOutputType[P]>
            : GetScalarType<T[P], CoursesGroupByOutputType[P]>
        }
      >
    >


  export type CoursesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_id?: boolean
    course_name?: boolean
    course_cost?: boolean
    course_description?: boolean
    course_descipline?: boolean
    Desciplines?: boolean | DesciplinesDefaultArgs<ExtArgs>
    Materials?: boolean | Courses$MaterialsArgs<ExtArgs>
    StudentToCourse?: boolean | Courses$StudentToCourseArgs<ExtArgs>
    TeacherToCourse?: boolean | Courses$TeacherToCourseArgs<ExtArgs>
    Tests?: boolean | Courses$TestsArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courses"]>

  export type CoursesSelectScalar = {
    course_id?: boolean
    course_name?: boolean
    course_cost?: boolean
    course_description?: boolean
    course_descipline?: boolean
  }

  export type CoursesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Desciplines?: boolean | DesciplinesDefaultArgs<ExtArgs>
    Materials?: boolean | Courses$MaterialsArgs<ExtArgs>
    StudentToCourse?: boolean | Courses$StudentToCourseArgs<ExtArgs>
    TeacherToCourse?: boolean | Courses$TeacherToCourseArgs<ExtArgs>
    Tests?: boolean | Courses$TestsArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CoursesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Courses"
    objects: {
      Desciplines: Prisma.$DesciplinesPayload<ExtArgs>
      Materials: Prisma.$MaterialsPayload<ExtArgs>[]
      StudentToCourse: Prisma.$StudentToCoursePayload<ExtArgs>[]
      TeacherToCourse: Prisma.$TeacherToCoursePayload<ExtArgs>[]
      Tests: Prisma.$TestsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      course_id: number
      course_name: string
      course_cost: number
      course_description: string | null
      course_descipline: string
    }, ExtArgs["result"]["courses"]>
    composites: {}
  }


  type CoursesGetPayload<S extends boolean | null | undefined | CoursesDefaultArgs> = $Result.GetResult<Prisma.$CoursesPayload, S>

  type CoursesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoursesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoursesCountAggregateInputType | true
    }

  export interface CoursesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Courses'], meta: { name: 'Courses' } }
    /**
     * Find zero or one Courses that matches the filter.
     * @param {CoursesFindUniqueArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CoursesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesFindUniqueArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Courses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CoursesFindUniqueOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CoursesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindFirstArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CoursesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesFindFirstArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Courses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindFirstOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CoursesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.courses.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.courses.findMany({ take: 10 })
     * 
     * // Only select the `course_id`
     * const coursesWithCourse_idOnly = await prisma.courses.findMany({ select: { course_id: true } })
     * 
    **/
    findMany<T extends CoursesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Courses.
     * @param {CoursesCreateArgs} args - Arguments to create a Courses.
     * @example
     * // Create one Courses
     * const Courses = await prisma.courses.create({
     *   data: {
     *     // ... data to create a Courses
     *   }
     * })
     * 
    **/
    create<T extends CoursesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesCreateArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Courses.
     *     @param {CoursesCreateManyArgs} args - Arguments to create many Courses.
     *     @example
     *     // Create many Courses
     *     const courses = await prisma.courses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CoursesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Courses.
     * @param {CoursesDeleteArgs} args - Arguments to delete one Courses.
     * @example
     * // Delete one Courses
     * const Courses = await prisma.courses.delete({
     *   where: {
     *     // ... filter to delete one Courses
     *   }
     * })
     * 
    **/
    delete<T extends CoursesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesDeleteArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Courses.
     * @param {CoursesUpdateArgs} args - Arguments to update one Courses.
     * @example
     * // Update one Courses
     * const courses = await prisma.courses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CoursesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesUpdateArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CoursesDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.courses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CoursesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CoursesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const courses = await prisma.courses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CoursesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Courses.
     * @param {CoursesUpsertArgs} args - Arguments to update or create a Courses.
     * @example
     * // Update or create a Courses
     * const courses = await prisma.courses.upsert({
     *   create: {
     *     // ... data to create a Courses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courses we want to update
     *   }
     * })
    **/
    upsert<T extends CoursesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CoursesUpsertArgs<ExtArgs>>
    ): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.courses.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CoursesCountArgs>(
      args?: Subset<T, CoursesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursesAggregateArgs>(args: Subset<T, CoursesAggregateArgs>): Prisma.PrismaPromise<GetCoursesAggregateType<T>>

    /**
     * Group by Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoursesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoursesGroupByArgs['orderBy'] }
        : { orderBy?: CoursesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoursesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Courses model
   */
  readonly fields: CoursesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Courses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoursesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Desciplines<T extends DesciplinesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DesciplinesDefaultArgs<ExtArgs>>): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Materials<T extends Courses$MaterialsArgs<ExtArgs> = {}>(args?: Subset<T, Courses$MaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findMany'> | Null>;

    StudentToCourse<T extends Courses$StudentToCourseArgs<ExtArgs> = {}>(args?: Subset<T, Courses$StudentToCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    TeacherToCourse<T extends Courses$TeacherToCourseArgs<ExtArgs> = {}>(args?: Subset<T, Courses$TeacherToCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    Tests<T extends Courses$TestsArgs<ExtArgs> = {}>(args?: Subset<T, Courses$TestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Courses model
   */ 
  interface CoursesFieldRefs {
    readonly course_id: FieldRef<"Courses", 'Int'>
    readonly course_name: FieldRef<"Courses", 'String'>
    readonly course_cost: FieldRef<"Courses", 'Int'>
    readonly course_description: FieldRef<"Courses", 'String'>
    readonly course_descipline: FieldRef<"Courses", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Courses findUnique
   */
  export type CoursesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where: CoursesWhereUniqueInput
  }


  /**
   * Courses findUniqueOrThrow
   */
  export type CoursesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where: CoursesWhereUniqueInput
  }


  /**
   * Courses findFirst
   */
  export type CoursesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }


  /**
   * Courses findFirstOrThrow
   */
  export type CoursesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }


  /**
   * Courses findMany
   */
  export type CoursesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CoursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CoursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }


  /**
   * Courses create
   */
  export type CoursesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * The data needed to create a Courses.
     */
    data: XOR<CoursesCreateInput, CoursesUncheckedCreateInput>
  }


  /**
   * Courses createMany
   */
  export type CoursesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CoursesCreateManyInput | CoursesCreateManyInput[]
  }


  /**
   * Courses update
   */
  export type CoursesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * The data needed to update a Courses.
     */
    data: XOR<CoursesUpdateInput, CoursesUncheckedUpdateInput>
    /**
     * Choose, which Courses to update.
     */
    where: CoursesWhereUniqueInput
  }


  /**
   * Courses updateMany
   */
  export type CoursesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CoursesUpdateManyMutationInput, CoursesUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CoursesWhereInput
  }


  /**
   * Courses upsert
   */
  export type CoursesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * The filter to search for the Courses to update in case it exists.
     */
    where: CoursesWhereUniqueInput
    /**
     * In case the Courses found by the `where` argument doesn't exist, create a new Courses with this data.
     */
    create: XOR<CoursesCreateInput, CoursesUncheckedCreateInput>
    /**
     * In case the Courses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoursesUpdateInput, CoursesUncheckedUpdateInput>
  }


  /**
   * Courses delete
   */
  export type CoursesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    /**
     * Filter which Courses to delete.
     */
    where: CoursesWhereUniqueInput
  }


  /**
   * Courses deleteMany
   */
  export type CoursesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CoursesWhereInput
  }


  /**
   * Courses.Materials
   */
  export type Courses$MaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    where?: MaterialsWhereInput
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    cursor?: MaterialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }


  /**
   * Courses.StudentToCourse
   */
  export type Courses$StudentToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    where?: StudentToCourseWhereInput
    orderBy?: StudentToCourseOrderByWithRelationInput | StudentToCourseOrderByWithRelationInput[]
    cursor?: StudentToCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentToCourseScalarFieldEnum | StudentToCourseScalarFieldEnum[]
  }


  /**
   * Courses.TeacherToCourse
   */
  export type Courses$TeacherToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    where?: TeacherToCourseWhereInput
    orderBy?: TeacherToCourseOrderByWithRelationInput | TeacherToCourseOrderByWithRelationInput[]
    cursor?: TeacherToCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherToCourseScalarFieldEnum | TeacherToCourseScalarFieldEnum[]
  }


  /**
   * Courses.Tests
   */
  export type Courses$TestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    where?: TestsWhereInput
    orderBy?: TestsOrderByWithRelationInput | TestsOrderByWithRelationInput[]
    cursor?: TestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestsScalarFieldEnum | TestsScalarFieldEnum[]
  }


  /**
   * Courses without action
   */
  export type CoursesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
  }



  /**
   * Model Desciplines
   */

  export type AggregateDesciplines = {
    _count: DesciplinesCountAggregateOutputType | null
    _min: DesciplinesMinAggregateOutputType | null
    _max: DesciplinesMaxAggregateOutputType | null
  }

  export type DesciplinesMinAggregateOutputType = {
    descipline_name: string | null
  }

  export type DesciplinesMaxAggregateOutputType = {
    descipline_name: string | null
  }

  export type DesciplinesCountAggregateOutputType = {
    descipline_name: number
    _all: number
  }


  export type DesciplinesMinAggregateInputType = {
    descipline_name?: true
  }

  export type DesciplinesMaxAggregateInputType = {
    descipline_name?: true
  }

  export type DesciplinesCountAggregateInputType = {
    descipline_name?: true
    _all?: true
  }

  export type DesciplinesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Desciplines to aggregate.
     */
    where?: DesciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Desciplines to fetch.
     */
    orderBy?: DesciplinesOrderByWithRelationInput | DesciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DesciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Desciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Desciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Desciplines
    **/
    _count?: true | DesciplinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DesciplinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DesciplinesMaxAggregateInputType
  }

  export type GetDesciplinesAggregateType<T extends DesciplinesAggregateArgs> = {
        [P in keyof T & keyof AggregateDesciplines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDesciplines[P]>
      : GetScalarType<T[P], AggregateDesciplines[P]>
  }




  export type DesciplinesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DesciplinesWhereInput
    orderBy?: DesciplinesOrderByWithAggregationInput | DesciplinesOrderByWithAggregationInput[]
    by: DesciplinesScalarFieldEnum[] | DesciplinesScalarFieldEnum
    having?: DesciplinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DesciplinesCountAggregateInputType | true
    _min?: DesciplinesMinAggregateInputType
    _max?: DesciplinesMaxAggregateInputType
  }

  export type DesciplinesGroupByOutputType = {
    descipline_name: string
    _count: DesciplinesCountAggregateOutputType | null
    _min: DesciplinesMinAggregateOutputType | null
    _max: DesciplinesMaxAggregateOutputType | null
  }

  type GetDesciplinesGroupByPayload<T extends DesciplinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DesciplinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DesciplinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DesciplinesGroupByOutputType[P]>
            : GetScalarType<T[P], DesciplinesGroupByOutputType[P]>
        }
      >
    >


  export type DesciplinesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    descipline_name?: boolean
    Courses?: boolean | Desciplines$CoursesArgs<ExtArgs>
    Teachers?: boolean | Desciplines$TeachersArgs<ExtArgs>
    _count?: boolean | DesciplinesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["desciplines"]>

  export type DesciplinesSelectScalar = {
    descipline_name?: boolean
  }

  export type DesciplinesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | Desciplines$CoursesArgs<ExtArgs>
    Teachers?: boolean | Desciplines$TeachersArgs<ExtArgs>
    _count?: boolean | DesciplinesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DesciplinesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Desciplines"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>[]
      Teachers: Prisma.$TeachersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      descipline_name: string
    }, ExtArgs["result"]["desciplines"]>
    composites: {}
  }


  type DesciplinesGetPayload<S extends boolean | null | undefined | DesciplinesDefaultArgs> = $Result.GetResult<Prisma.$DesciplinesPayload, S>

  type DesciplinesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DesciplinesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DesciplinesCountAggregateInputType | true
    }

  export interface DesciplinesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Desciplines'], meta: { name: 'Desciplines' } }
    /**
     * Find zero or one Desciplines that matches the filter.
     * @param {DesciplinesFindUniqueArgs} args - Arguments to find a Desciplines
     * @example
     * // Get one Desciplines
     * const desciplines = await prisma.desciplines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DesciplinesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DesciplinesFindUniqueArgs<ExtArgs>>
    ): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Desciplines that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DesciplinesFindUniqueOrThrowArgs} args - Arguments to find a Desciplines
     * @example
     * // Get one Desciplines
     * const desciplines = await prisma.desciplines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DesciplinesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DesciplinesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Desciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesciplinesFindFirstArgs} args - Arguments to find a Desciplines
     * @example
     * // Get one Desciplines
     * const desciplines = await prisma.desciplines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DesciplinesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DesciplinesFindFirstArgs<ExtArgs>>
    ): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Desciplines that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesciplinesFindFirstOrThrowArgs} args - Arguments to find a Desciplines
     * @example
     * // Get one Desciplines
     * const desciplines = await prisma.desciplines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DesciplinesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DesciplinesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Desciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesciplinesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Desciplines
     * const desciplines = await prisma.desciplines.findMany()
     * 
     * // Get first 10 Desciplines
     * const desciplines = await prisma.desciplines.findMany({ take: 10 })
     * 
     * // Only select the `descipline_name`
     * const desciplinesWithDescipline_nameOnly = await prisma.desciplines.findMany({ select: { descipline_name: true } })
     * 
    **/
    findMany<T extends DesciplinesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DesciplinesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Desciplines.
     * @param {DesciplinesCreateArgs} args - Arguments to create a Desciplines.
     * @example
     * // Create one Desciplines
     * const Desciplines = await prisma.desciplines.create({
     *   data: {
     *     // ... data to create a Desciplines
     *   }
     * })
     * 
    **/
    create<T extends DesciplinesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DesciplinesCreateArgs<ExtArgs>>
    ): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Desciplines.
     *     @param {DesciplinesCreateManyArgs} args - Arguments to create many Desciplines.
     *     @example
     *     // Create many Desciplines
     *     const desciplines = await prisma.desciplines.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DesciplinesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DesciplinesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Desciplines.
     * @param {DesciplinesDeleteArgs} args - Arguments to delete one Desciplines.
     * @example
     * // Delete one Desciplines
     * const Desciplines = await prisma.desciplines.delete({
     *   where: {
     *     // ... filter to delete one Desciplines
     *   }
     * })
     * 
    **/
    delete<T extends DesciplinesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DesciplinesDeleteArgs<ExtArgs>>
    ): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Desciplines.
     * @param {DesciplinesUpdateArgs} args - Arguments to update one Desciplines.
     * @example
     * // Update one Desciplines
     * const desciplines = await prisma.desciplines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DesciplinesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DesciplinesUpdateArgs<ExtArgs>>
    ): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Desciplines.
     * @param {DesciplinesDeleteManyArgs} args - Arguments to filter Desciplines to delete.
     * @example
     * // Delete a few Desciplines
     * const { count } = await prisma.desciplines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DesciplinesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DesciplinesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Desciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesciplinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Desciplines
     * const desciplines = await prisma.desciplines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DesciplinesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DesciplinesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Desciplines.
     * @param {DesciplinesUpsertArgs} args - Arguments to update or create a Desciplines.
     * @example
     * // Update or create a Desciplines
     * const desciplines = await prisma.desciplines.upsert({
     *   create: {
     *     // ... data to create a Desciplines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Desciplines we want to update
     *   }
     * })
    **/
    upsert<T extends DesciplinesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DesciplinesUpsertArgs<ExtArgs>>
    ): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Desciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesciplinesCountArgs} args - Arguments to filter Desciplines to count.
     * @example
     * // Count the number of Desciplines
     * const count = await prisma.desciplines.count({
     *   where: {
     *     // ... the filter for the Desciplines we want to count
     *   }
     * })
    **/
    count<T extends DesciplinesCountArgs>(
      args?: Subset<T, DesciplinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DesciplinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Desciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesciplinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DesciplinesAggregateArgs>(args: Subset<T, DesciplinesAggregateArgs>): Prisma.PrismaPromise<GetDesciplinesAggregateType<T>>

    /**
     * Group by Desciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DesciplinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DesciplinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DesciplinesGroupByArgs['orderBy'] }
        : { orderBy?: DesciplinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DesciplinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDesciplinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Desciplines model
   */
  readonly fields: DesciplinesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Desciplines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DesciplinesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends Desciplines$CoursesArgs<ExtArgs> = {}>(args?: Subset<T, Desciplines$CoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Teachers<T extends Desciplines$TeachersArgs<ExtArgs> = {}>(args?: Subset<T, Desciplines$TeachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Desciplines model
   */ 
  interface DesciplinesFieldRefs {
    readonly descipline_name: FieldRef<"Desciplines", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Desciplines findUnique
   */
  export type DesciplinesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
    /**
     * Filter, which Desciplines to fetch.
     */
    where: DesciplinesWhereUniqueInput
  }


  /**
   * Desciplines findUniqueOrThrow
   */
  export type DesciplinesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
    /**
     * Filter, which Desciplines to fetch.
     */
    where: DesciplinesWhereUniqueInput
  }


  /**
   * Desciplines findFirst
   */
  export type DesciplinesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
    /**
     * Filter, which Desciplines to fetch.
     */
    where?: DesciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Desciplines to fetch.
     */
    orderBy?: DesciplinesOrderByWithRelationInput | DesciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Desciplines.
     */
    cursor?: DesciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Desciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Desciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Desciplines.
     */
    distinct?: DesciplinesScalarFieldEnum | DesciplinesScalarFieldEnum[]
  }


  /**
   * Desciplines findFirstOrThrow
   */
  export type DesciplinesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
    /**
     * Filter, which Desciplines to fetch.
     */
    where?: DesciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Desciplines to fetch.
     */
    orderBy?: DesciplinesOrderByWithRelationInput | DesciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Desciplines.
     */
    cursor?: DesciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Desciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Desciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Desciplines.
     */
    distinct?: DesciplinesScalarFieldEnum | DesciplinesScalarFieldEnum[]
  }


  /**
   * Desciplines findMany
   */
  export type DesciplinesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
    /**
     * Filter, which Desciplines to fetch.
     */
    where?: DesciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Desciplines to fetch.
     */
    orderBy?: DesciplinesOrderByWithRelationInput | DesciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Desciplines.
     */
    cursor?: DesciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Desciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Desciplines.
     */
    skip?: number
    distinct?: DesciplinesScalarFieldEnum | DesciplinesScalarFieldEnum[]
  }


  /**
   * Desciplines create
   */
  export type DesciplinesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
    /**
     * The data needed to create a Desciplines.
     */
    data: XOR<DesciplinesCreateInput, DesciplinesUncheckedCreateInput>
  }


  /**
   * Desciplines createMany
   */
  export type DesciplinesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Desciplines.
     */
    data: DesciplinesCreateManyInput | DesciplinesCreateManyInput[]
  }


  /**
   * Desciplines update
   */
  export type DesciplinesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
    /**
     * The data needed to update a Desciplines.
     */
    data: XOR<DesciplinesUpdateInput, DesciplinesUncheckedUpdateInput>
    /**
     * Choose, which Desciplines to update.
     */
    where: DesciplinesWhereUniqueInput
  }


  /**
   * Desciplines updateMany
   */
  export type DesciplinesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Desciplines.
     */
    data: XOR<DesciplinesUpdateManyMutationInput, DesciplinesUncheckedUpdateManyInput>
    /**
     * Filter which Desciplines to update
     */
    where?: DesciplinesWhereInput
  }


  /**
   * Desciplines upsert
   */
  export type DesciplinesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
    /**
     * The filter to search for the Desciplines to update in case it exists.
     */
    where: DesciplinesWhereUniqueInput
    /**
     * In case the Desciplines found by the `where` argument doesn't exist, create a new Desciplines with this data.
     */
    create: XOR<DesciplinesCreateInput, DesciplinesUncheckedCreateInput>
    /**
     * In case the Desciplines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DesciplinesUpdateInput, DesciplinesUncheckedUpdateInput>
  }


  /**
   * Desciplines delete
   */
  export type DesciplinesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
    /**
     * Filter which Desciplines to delete.
     */
    where: DesciplinesWhereUniqueInput
  }


  /**
   * Desciplines deleteMany
   */
  export type DesciplinesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Desciplines to delete
     */
    where?: DesciplinesWhereInput
  }


  /**
   * Desciplines.Courses
   */
  export type Desciplines$CoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courses
     */
    select?: CoursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CoursesInclude<ExtArgs> | null
    where?: CoursesWhereInput
    orderBy?: CoursesOrderByWithRelationInput | CoursesOrderByWithRelationInput[]
    cursor?: CoursesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }


  /**
   * Desciplines.Teachers
   */
  export type Desciplines$TeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    where?: TeachersWhereInput
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    cursor?: TeachersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }


  /**
   * Desciplines without action
   */
  export type DesciplinesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Desciplines
     */
    select?: DesciplinesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DesciplinesInclude<ExtArgs> | null
  }



  /**
   * Model Materials
   */

  export type AggregateMaterials = {
    _count: MaterialsCountAggregateOutputType | null
    _avg: MaterialsAvgAggregateOutputType | null
    _sum: MaterialsSumAggregateOutputType | null
    _min: MaterialsMinAggregateOutputType | null
    _max: MaterialsMaxAggregateOutputType | null
  }

  export type MaterialsAvgAggregateOutputType = {
    material_id: number | null
    course_id: number | null
  }

  export type MaterialsSumAggregateOutputType = {
    material_id: number | null
    course_id: number | null
  }

  export type MaterialsMinAggregateOutputType = {
    material_id: number | null
    material_name: string | null
    course_id: number | null
    material_ingo: string | null
  }

  export type MaterialsMaxAggregateOutputType = {
    material_id: number | null
    material_name: string | null
    course_id: number | null
    material_ingo: string | null
  }

  export type MaterialsCountAggregateOutputType = {
    material_id: number
    material_name: number
    course_id: number
    material_ingo: number
    _all: number
  }


  export type MaterialsAvgAggregateInputType = {
    material_id?: true
    course_id?: true
  }

  export type MaterialsSumAggregateInputType = {
    material_id?: true
    course_id?: true
  }

  export type MaterialsMinAggregateInputType = {
    material_id?: true
    material_name?: true
    course_id?: true
    material_ingo?: true
  }

  export type MaterialsMaxAggregateInputType = {
    material_id?: true
    material_name?: true
    course_id?: true
    material_ingo?: true
  }

  export type MaterialsCountAggregateInputType = {
    material_id?: true
    material_name?: true
    course_id?: true
    material_ingo?: true
    _all?: true
  }

  export type MaterialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to aggregate.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialsMaxAggregateInputType
  }

  export type GetMaterialsAggregateType<T extends MaterialsAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterials[P]>
      : GetScalarType<T[P], AggregateMaterials[P]>
  }




  export type MaterialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialsWhereInput
    orderBy?: MaterialsOrderByWithAggregationInput | MaterialsOrderByWithAggregationInput[]
    by: MaterialsScalarFieldEnum[] | MaterialsScalarFieldEnum
    having?: MaterialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialsCountAggregateInputType | true
    _avg?: MaterialsAvgAggregateInputType
    _sum?: MaterialsSumAggregateInputType
    _min?: MaterialsMinAggregateInputType
    _max?: MaterialsMaxAggregateInputType
  }

  export type MaterialsGroupByOutputType = {
    material_id: number
    material_name: string
    course_id: number
    material_ingo: string | null
    _count: MaterialsCountAggregateOutputType | null
    _avg: MaterialsAvgAggregateOutputType | null
    _sum: MaterialsSumAggregateOutputType | null
    _min: MaterialsMinAggregateOutputType | null
    _max: MaterialsMaxAggregateOutputType | null
  }

  type GetMaterialsGroupByPayload<T extends MaterialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialsGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialsGroupByOutputType[P]>
        }
      >
    >


  export type MaterialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    material_id?: boolean
    material_name?: boolean
    course_id?: boolean
    material_ingo?: boolean
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materials"]>

  export type MaterialsSelectScalar = {
    material_id?: boolean
    material_name?: boolean
    course_id?: boolean
    material_ingo?: boolean
  }

  export type MaterialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
  }


  export type $MaterialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Materials"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      material_id: number
      material_name: string
      course_id: number
      material_ingo: string | null
    }, ExtArgs["result"]["materials"]>
    composites: {}
  }


  type MaterialsGetPayload<S extends boolean | null | undefined | MaterialsDefaultArgs> = $Result.GetResult<Prisma.$MaterialsPayload, S>

  type MaterialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaterialsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaterialsCountAggregateInputType | true
    }

  export interface MaterialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Materials'], meta: { name: 'Materials' } }
    /**
     * Find zero or one Materials that matches the filter.
     * @param {MaterialsFindUniqueArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MaterialsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsFindUniqueArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Materials that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MaterialsFindUniqueOrThrowArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MaterialsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsFindFirstArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MaterialsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsFindFirstArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Materials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsFindFirstOrThrowArgs} args - Arguments to find a Materials
     * @example
     * // Get one Materials
     * const materials = await prisma.materials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MaterialsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.materials.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.materials.findMany({ take: 10 })
     * 
     * // Only select the `material_id`
     * const materialsWithMaterial_idOnly = await prisma.materials.findMany({ select: { material_id: true } })
     * 
    **/
    findMany<T extends MaterialsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Materials.
     * @param {MaterialsCreateArgs} args - Arguments to create a Materials.
     * @example
     * // Create one Materials
     * const Materials = await prisma.materials.create({
     *   data: {
     *     // ... data to create a Materials
     *   }
     * })
     * 
    **/
    create<T extends MaterialsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsCreateArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Materials.
     *     @param {MaterialsCreateManyArgs} args - Arguments to create many Materials.
     *     @example
     *     // Create many Materials
     *     const materials = await prisma.materials.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MaterialsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Materials.
     * @param {MaterialsDeleteArgs} args - Arguments to delete one Materials.
     * @example
     * // Delete one Materials
     * const Materials = await prisma.materials.delete({
     *   where: {
     *     // ... filter to delete one Materials
     *   }
     * })
     * 
    **/
    delete<T extends MaterialsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsDeleteArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Materials.
     * @param {MaterialsUpdateArgs} args - Arguments to update one Materials.
     * @example
     * // Update one Materials
     * const materials = await prisma.materials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MaterialsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsUpdateArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Materials.
     * @param {MaterialsDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.materials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MaterialsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MaterialsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const materials = await prisma.materials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MaterialsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materials.
     * @param {MaterialsUpsertArgs} args - Arguments to update or create a Materials.
     * @example
     * // Update or create a Materials
     * const materials = await prisma.materials.upsert({
     *   create: {
     *     // ... data to create a Materials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materials we want to update
     *   }
     * })
    **/
    upsert<T extends MaterialsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MaterialsUpsertArgs<ExtArgs>>
    ): Prisma__MaterialsClient<$Result.GetResult<Prisma.$MaterialsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.materials.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialsCountArgs>(
      args?: Subset<T, MaterialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialsAggregateArgs>(args: Subset<T, MaterialsAggregateArgs>): Prisma.PrismaPromise<GetMaterialsAggregateType<T>>

    /**
     * Group by Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialsGroupByArgs['orderBy'] }
        : { orderBy?: MaterialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Materials model
   */
  readonly fields: MaterialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Materials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Materials model
   */ 
  interface MaterialsFieldRefs {
    readonly material_id: FieldRef<"Materials", 'Int'>
    readonly material_name: FieldRef<"Materials", 'String'>
    readonly course_id: FieldRef<"Materials", 'Int'>
    readonly material_ingo: FieldRef<"Materials", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Materials findUnique
   */
  export type MaterialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where: MaterialsWhereUniqueInput
  }


  /**
   * Materials findUniqueOrThrow
   */
  export type MaterialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where: MaterialsWhereUniqueInput
  }


  /**
   * Materials findFirst
   */
  export type MaterialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }


  /**
   * Materials findFirstOrThrow
   */
  export type MaterialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }


  /**
   * Materials findMany
   */
  export type MaterialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialsOrderByWithRelationInput | MaterialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialsScalarFieldEnum | MaterialsScalarFieldEnum[]
  }


  /**
   * Materials create
   */
  export type MaterialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * The data needed to create a Materials.
     */
    data: XOR<MaterialsCreateInput, MaterialsUncheckedCreateInput>
  }


  /**
   * Materials createMany
   */
  export type MaterialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialsCreateManyInput | MaterialsCreateManyInput[]
  }


  /**
   * Materials update
   */
  export type MaterialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * The data needed to update a Materials.
     */
    data: XOR<MaterialsUpdateInput, MaterialsUncheckedUpdateInput>
    /**
     * Choose, which Materials to update.
     */
    where: MaterialsWhereUniqueInput
  }


  /**
   * Materials updateMany
   */
  export type MaterialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialsUpdateManyMutationInput, MaterialsUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialsWhereInput
  }


  /**
   * Materials upsert
   */
  export type MaterialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * The filter to search for the Materials to update in case it exists.
     */
    where: MaterialsWhereUniqueInput
    /**
     * In case the Materials found by the `where` argument doesn't exist, create a new Materials with this data.
     */
    create: XOR<MaterialsCreateInput, MaterialsUncheckedCreateInput>
    /**
     * In case the Materials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialsUpdateInput, MaterialsUncheckedUpdateInput>
  }


  /**
   * Materials delete
   */
  export type MaterialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
    /**
     * Filter which Materials to delete.
     */
    where: MaterialsWhereUniqueInput
  }


  /**
   * Materials deleteMany
   */
  export type MaterialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialsWhereInput
  }


  /**
   * Materials without action
   */
  export type MaterialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Materials
     */
    select?: MaterialsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MaterialsInclude<ExtArgs> | null
  }



  /**
   * Model Students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsAvgAggregateOutputType = {
    user_ident: number | null
    balance: number | null
  }

  export type StudentsSumAggregateOutputType = {
    user_ident: number | null
    balance: number | null
  }

  export type StudentsMinAggregateOutputType = {
    user_ident: number | null
    fio: string | null
    balance: number | null
    email: string | null
    user_password: string | null
  }

  export type StudentsMaxAggregateOutputType = {
    user_ident: number | null
    fio: string | null
    balance: number | null
    email: string | null
    user_password: string | null
  }

  export type StudentsCountAggregateOutputType = {
    user_ident: number
    fio: number
    balance: number
    email: number
    user_password: number
    _all: number
  }


  export type StudentsAvgAggregateInputType = {
    user_ident?: true
    balance?: true
  }

  export type StudentsSumAggregateInputType = {
    user_ident?: true
    balance?: true
  }

  export type StudentsMinAggregateInputType = {
    user_ident?: true
    fio?: true
    balance?: true
    email?: true
    user_password?: true
  }

  export type StudentsMaxAggregateInputType = {
    user_ident?: true
    fio?: true
    balance?: true
    email?: true
    user_password?: true
  }

  export type StudentsCountAggregateInputType = {
    user_ident?: true
    fio?: true
    balance?: true
    email?: true
    user_password?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to aggregate.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type StudentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentsWhereInput
    orderBy?: StudentsOrderByWithAggregationInput | StudentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: StudentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _avg?: StudentsAvgAggregateInputType
    _sum?: StudentsSumAggregateInputType
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    user_ident: number
    fio: string
    balance: number | null
    email: string
    user_password: string
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends StudentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type StudentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_ident?: boolean
    fio?: boolean
    balance?: boolean
    email?: boolean
    user_password?: boolean
    StudentToCourse?: boolean | Students$StudentToCourseArgs<ExtArgs>
    TestStatus?: boolean | Students$TestStatusArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type StudentsSelectScalar = {
    user_ident?: boolean
    fio?: boolean
    balance?: boolean
    email?: boolean
    user_password?: boolean
  }

  export type StudentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    StudentToCourse?: boolean | Students$StudentToCourseArgs<ExtArgs>
    TestStatus?: boolean | Students$TestStatusArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StudentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Students"
    objects: {
      StudentToCourse: Prisma.$StudentToCoursePayload<ExtArgs>[]
      TestStatus: Prisma.$TestStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_ident: number
      fio: string
      balance: number | null
      email: string
      user_password: string
    }, ExtArgs["result"]["students"]>
    composites: {}
  }


  type StudentsGetPayload<S extends boolean | null | undefined | StudentsDefaultArgs> = $Result.GetResult<Prisma.$StudentsPayload, S>

  type StudentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface StudentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Students'], meta: { name: 'Students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {StudentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentsFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Students that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentsFindFirstArgs<ExtArgs>>
    ): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `user_ident`
     * const studentsWithUser_identOnly = await prisma.students.findMany({ select: { user_ident: true } })
     * 
    **/
    findMany<T extends StudentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Students.
     * @param {StudentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
    **/
    create<T extends StudentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentsCreateArgs<ExtArgs>>
    ): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Students.
     *     @param {StudentsCreateManyArgs} args - Arguments to create many Students.
     *     @example
     *     // Create many Students
     *     const students = await prisma.students.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Students.
     * @param {StudentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
    **/
    delete<T extends StudentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentsDeleteArgs<ExtArgs>>
    ): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Students.
     * @param {StudentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentsUpdateArgs<ExtArgs>>
    ): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Students.
     * @param {StudentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
    **/
    upsert<T extends StudentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentsUpsertArgs<ExtArgs>>
    ): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentsCountArgs>(
      args?: Subset<T, StudentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentsGroupByArgs['orderBy'] }
        : { orderBy?: StudentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Students model
   */
  readonly fields: StudentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    StudentToCourse<T extends Students$StudentToCourseArgs<ExtArgs> = {}>(args?: Subset<T, Students$StudentToCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    TestStatus<T extends Students$TestStatusArgs<ExtArgs> = {}>(args?: Subset<T, Students$TestStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Students model
   */ 
  interface StudentsFieldRefs {
    readonly user_ident: FieldRef<"Students", 'Int'>
    readonly fio: FieldRef<"Students", 'String'>
    readonly balance: FieldRef<"Students", 'Int'>
    readonly email: FieldRef<"Students", 'String'>
    readonly user_password: FieldRef<"Students", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Students findUnique
   */
  export type StudentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where: StudentsWhereUniqueInput
  }


  /**
   * Students findUniqueOrThrow
   */
  export type StudentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where: StudentsWhereUniqueInput
  }


  /**
   * Students findFirst
   */
  export type StudentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }


  /**
   * Students findFirstOrThrow
   */
  export type StudentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }


  /**
   * Students findMany
   */
  export type StudentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentsOrderByWithRelationInput | StudentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }


  /**
   * Students create
   */
  export type StudentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Students.
     */
    data: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
  }


  /**
   * Students createMany
   */
  export type StudentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentsCreateManyInput | StudentsCreateManyInput[]
  }


  /**
   * Students update
   */
  export type StudentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Students.
     */
    data: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
    /**
     * Choose, which Students to update.
     */
    where: StudentsWhereUniqueInput
  }


  /**
   * Students updateMany
   */
  export type StudentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentsUpdateManyMutationInput, StudentsUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentsWhereInput
  }


  /**
   * Students upsert
   */
  export type StudentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Students to update in case it exists.
     */
    where: StudentsWhereUniqueInput
    /**
     * In case the Students found by the `where` argument doesn't exist, create a new Students with this data.
     */
    create: XOR<StudentsCreateInput, StudentsUncheckedCreateInput>
    /**
     * In case the Students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentsUpdateInput, StudentsUncheckedUpdateInput>
  }


  /**
   * Students delete
   */
  export type StudentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
    /**
     * Filter which Students to delete.
     */
    where: StudentsWhereUniqueInput
  }


  /**
   * Students deleteMany
   */
  export type StudentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentsWhereInput
  }


  /**
   * Students.StudentToCourse
   */
  export type Students$StudentToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    where?: StudentToCourseWhereInput
    orderBy?: StudentToCourseOrderByWithRelationInput | StudentToCourseOrderByWithRelationInput[]
    cursor?: StudentToCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentToCourseScalarFieldEnum | StudentToCourseScalarFieldEnum[]
  }


  /**
   * Students.TestStatus
   */
  export type Students$TestStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    where?: TestStatusWhereInput
    orderBy?: TestStatusOrderByWithRelationInput | TestStatusOrderByWithRelationInput[]
    cursor?: TestStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestStatusScalarFieldEnum | TestStatusScalarFieldEnum[]
  }


  /**
   * Students without action
   */
  export type StudentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Students
     */
    select?: StudentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentsInclude<ExtArgs> | null
  }



  /**
   * Model StudentToCourse
   */

  export type AggregateStudentToCourse = {
    _count: StudentToCourseCountAggregateOutputType | null
    _avg: StudentToCourseAvgAggregateOutputType | null
    _sum: StudentToCourseSumAggregateOutputType | null
    _min: StudentToCourseMinAggregateOutputType | null
    _max: StudentToCourseMaxAggregateOutputType | null
  }

  export type StudentToCourseAvgAggregateOutputType = {
    STC_id: number | null
    course_id: number | null
    student_id: number | null
  }

  export type StudentToCourseSumAggregateOutputType = {
    STC_id: number | null
    course_id: number | null
    student_id: number | null
  }

  export type StudentToCourseMinAggregateOutputType = {
    STC_id: number | null
    course_id: number | null
    student_id: number | null
  }

  export type StudentToCourseMaxAggregateOutputType = {
    STC_id: number | null
    course_id: number | null
    student_id: number | null
  }

  export type StudentToCourseCountAggregateOutputType = {
    STC_id: number
    course_id: number
    student_id: number
    _all: number
  }


  export type StudentToCourseAvgAggregateInputType = {
    STC_id?: true
    course_id?: true
    student_id?: true
  }

  export type StudentToCourseSumAggregateInputType = {
    STC_id?: true
    course_id?: true
    student_id?: true
  }

  export type StudentToCourseMinAggregateInputType = {
    STC_id?: true
    course_id?: true
    student_id?: true
  }

  export type StudentToCourseMaxAggregateInputType = {
    STC_id?: true
    course_id?: true
    student_id?: true
  }

  export type StudentToCourseCountAggregateInputType = {
    STC_id?: true
    course_id?: true
    student_id?: true
    _all?: true
  }

  export type StudentToCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentToCourse to aggregate.
     */
    where?: StudentToCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentToCourses to fetch.
     */
    orderBy?: StudentToCourseOrderByWithRelationInput | StudentToCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentToCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentToCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentToCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentToCourses
    **/
    _count?: true | StudentToCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentToCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentToCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentToCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentToCourseMaxAggregateInputType
  }

  export type GetStudentToCourseAggregateType<T extends StudentToCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentToCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentToCourse[P]>
      : GetScalarType<T[P], AggregateStudentToCourse[P]>
  }




  export type StudentToCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentToCourseWhereInput
    orderBy?: StudentToCourseOrderByWithAggregationInput | StudentToCourseOrderByWithAggregationInput[]
    by: StudentToCourseScalarFieldEnum[] | StudentToCourseScalarFieldEnum
    having?: StudentToCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentToCourseCountAggregateInputType | true
    _avg?: StudentToCourseAvgAggregateInputType
    _sum?: StudentToCourseSumAggregateInputType
    _min?: StudentToCourseMinAggregateInputType
    _max?: StudentToCourseMaxAggregateInputType
  }

  export type StudentToCourseGroupByOutputType = {
    STC_id: number
    course_id: number
    student_id: number
    _count: StudentToCourseCountAggregateOutputType | null
    _avg: StudentToCourseAvgAggregateOutputType | null
    _sum: StudentToCourseSumAggregateOutputType | null
    _min: StudentToCourseMinAggregateOutputType | null
    _max: StudentToCourseMaxAggregateOutputType | null
  }

  type GetStudentToCourseGroupByPayload<T extends StudentToCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentToCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentToCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentToCourseGroupByOutputType[P]>
            : GetScalarType<T[P], StudentToCourseGroupByOutputType[P]>
        }
      >
    >


  export type StudentToCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    STC_id?: boolean
    course_id?: boolean
    student_id?: boolean
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Students?: boolean | StudentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentToCourse"]>

  export type StudentToCourseSelectScalar = {
    STC_id?: boolean
    course_id?: boolean
    student_id?: boolean
  }

  export type StudentToCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Students?: boolean | StudentsDefaultArgs<ExtArgs>
  }


  export type $StudentToCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentToCourse"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>
      Students: Prisma.$StudentsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      STC_id: number
      course_id: number
      student_id: number
    }, ExtArgs["result"]["studentToCourse"]>
    composites: {}
  }


  type StudentToCourseGetPayload<S extends boolean | null | undefined | StudentToCourseDefaultArgs> = $Result.GetResult<Prisma.$StudentToCoursePayload, S>

  type StudentToCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentToCourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentToCourseCountAggregateInputType | true
    }

  export interface StudentToCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentToCourse'], meta: { name: 'StudentToCourse' } }
    /**
     * Find zero or one StudentToCourse that matches the filter.
     * @param {StudentToCourseFindUniqueArgs} args - Arguments to find a StudentToCourse
     * @example
     * // Get one StudentToCourse
     * const studentToCourse = await prisma.studentToCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StudentToCourseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StudentToCourseFindUniqueArgs<ExtArgs>>
    ): Prisma__StudentToCourseClient<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentToCourse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StudentToCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentToCourse
     * @example
     * // Get one StudentToCourse
     * const studentToCourse = await prisma.studentToCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StudentToCourseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentToCourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StudentToCourseClient<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentToCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentToCourseFindFirstArgs} args - Arguments to find a StudentToCourse
     * @example
     * // Get one StudentToCourse
     * const studentToCourse = await prisma.studentToCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StudentToCourseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentToCourseFindFirstArgs<ExtArgs>>
    ): Prisma__StudentToCourseClient<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentToCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentToCourseFindFirstOrThrowArgs} args - Arguments to find a StudentToCourse
     * @example
     * // Get one StudentToCourse
     * const studentToCourse = await prisma.studentToCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StudentToCourseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentToCourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StudentToCourseClient<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentToCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentToCourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentToCourses
     * const studentToCourses = await prisma.studentToCourse.findMany()
     * 
     * // Get first 10 StudentToCourses
     * const studentToCourses = await prisma.studentToCourse.findMany({ take: 10 })
     * 
     * // Only select the `STC_id`
     * const studentToCourseWithSTC_idOnly = await prisma.studentToCourse.findMany({ select: { STC_id: true } })
     * 
    **/
    findMany<T extends StudentToCourseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentToCourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentToCourse.
     * @param {StudentToCourseCreateArgs} args - Arguments to create a StudentToCourse.
     * @example
     * // Create one StudentToCourse
     * const StudentToCourse = await prisma.studentToCourse.create({
     *   data: {
     *     // ... data to create a StudentToCourse
     *   }
     * })
     * 
    **/
    create<T extends StudentToCourseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentToCourseCreateArgs<ExtArgs>>
    ): Prisma__StudentToCourseClient<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentToCourses.
     *     @param {StudentToCourseCreateManyArgs} args - Arguments to create many StudentToCourses.
     *     @example
     *     // Create many StudentToCourses
     *     const studentToCourse = await prisma.studentToCourse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StudentToCourseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentToCourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentToCourse.
     * @param {StudentToCourseDeleteArgs} args - Arguments to delete one StudentToCourse.
     * @example
     * // Delete one StudentToCourse
     * const StudentToCourse = await prisma.studentToCourse.delete({
     *   where: {
     *     // ... filter to delete one StudentToCourse
     *   }
     * })
     * 
    **/
    delete<T extends StudentToCourseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StudentToCourseDeleteArgs<ExtArgs>>
    ): Prisma__StudentToCourseClient<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentToCourse.
     * @param {StudentToCourseUpdateArgs} args - Arguments to update one StudentToCourse.
     * @example
     * // Update one StudentToCourse
     * const studentToCourse = await prisma.studentToCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StudentToCourseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StudentToCourseUpdateArgs<ExtArgs>>
    ): Prisma__StudentToCourseClient<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentToCourses.
     * @param {StudentToCourseDeleteManyArgs} args - Arguments to filter StudentToCourses to delete.
     * @example
     * // Delete a few StudentToCourses
     * const { count } = await prisma.studentToCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StudentToCourseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StudentToCourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentToCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentToCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentToCourses
     * const studentToCourse = await prisma.studentToCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StudentToCourseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StudentToCourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentToCourse.
     * @param {StudentToCourseUpsertArgs} args - Arguments to update or create a StudentToCourse.
     * @example
     * // Update or create a StudentToCourse
     * const studentToCourse = await prisma.studentToCourse.upsert({
     *   create: {
     *     // ... data to create a StudentToCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentToCourse we want to update
     *   }
     * })
    **/
    upsert<T extends StudentToCourseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StudentToCourseUpsertArgs<ExtArgs>>
    ): Prisma__StudentToCourseClient<$Result.GetResult<Prisma.$StudentToCoursePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentToCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentToCourseCountArgs} args - Arguments to filter StudentToCourses to count.
     * @example
     * // Count the number of StudentToCourses
     * const count = await prisma.studentToCourse.count({
     *   where: {
     *     // ... the filter for the StudentToCourses we want to count
     *   }
     * })
    **/
    count<T extends StudentToCourseCountArgs>(
      args?: Subset<T, StudentToCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentToCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentToCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentToCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentToCourseAggregateArgs>(args: Subset<T, StudentToCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentToCourseAggregateType<T>>

    /**
     * Group by StudentToCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentToCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentToCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentToCourseGroupByArgs['orderBy'] }
        : { orderBy?: StudentToCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentToCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentToCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentToCourse model
   */
  readonly fields: StudentToCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentToCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentToCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Students<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StudentToCourse model
   */ 
  interface StudentToCourseFieldRefs {
    readonly STC_id: FieldRef<"StudentToCourse", 'Int'>
    readonly course_id: FieldRef<"StudentToCourse", 'Int'>
    readonly student_id: FieldRef<"StudentToCourse", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * StudentToCourse findUnique
   */
  export type StudentToCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentToCourse to fetch.
     */
    where: StudentToCourseWhereUniqueInput
  }


  /**
   * StudentToCourse findUniqueOrThrow
   */
  export type StudentToCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentToCourse to fetch.
     */
    where: StudentToCourseWhereUniqueInput
  }


  /**
   * StudentToCourse findFirst
   */
  export type StudentToCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentToCourse to fetch.
     */
    where?: StudentToCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentToCourses to fetch.
     */
    orderBy?: StudentToCourseOrderByWithRelationInput | StudentToCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentToCourses.
     */
    cursor?: StudentToCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentToCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentToCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentToCourses.
     */
    distinct?: StudentToCourseScalarFieldEnum | StudentToCourseScalarFieldEnum[]
  }


  /**
   * StudentToCourse findFirstOrThrow
   */
  export type StudentToCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentToCourse to fetch.
     */
    where?: StudentToCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentToCourses to fetch.
     */
    orderBy?: StudentToCourseOrderByWithRelationInput | StudentToCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentToCourses.
     */
    cursor?: StudentToCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentToCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentToCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentToCourses.
     */
    distinct?: StudentToCourseScalarFieldEnum | StudentToCourseScalarFieldEnum[]
  }


  /**
   * StudentToCourse findMany
   */
  export type StudentToCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentToCourses to fetch.
     */
    where?: StudentToCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentToCourses to fetch.
     */
    orderBy?: StudentToCourseOrderByWithRelationInput | StudentToCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentToCourses.
     */
    cursor?: StudentToCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentToCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentToCourses.
     */
    skip?: number
    distinct?: StudentToCourseScalarFieldEnum | StudentToCourseScalarFieldEnum[]
  }


  /**
   * StudentToCourse create
   */
  export type StudentToCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentToCourse.
     */
    data: XOR<StudentToCourseCreateInput, StudentToCourseUncheckedCreateInput>
  }


  /**
   * StudentToCourse createMany
   */
  export type StudentToCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentToCourses.
     */
    data: StudentToCourseCreateManyInput | StudentToCourseCreateManyInput[]
  }


  /**
   * StudentToCourse update
   */
  export type StudentToCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentToCourse.
     */
    data: XOR<StudentToCourseUpdateInput, StudentToCourseUncheckedUpdateInput>
    /**
     * Choose, which StudentToCourse to update.
     */
    where: StudentToCourseWhereUniqueInput
  }


  /**
   * StudentToCourse updateMany
   */
  export type StudentToCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentToCourses.
     */
    data: XOR<StudentToCourseUpdateManyMutationInput, StudentToCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentToCourses to update
     */
    where?: StudentToCourseWhereInput
  }


  /**
   * StudentToCourse upsert
   */
  export type StudentToCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentToCourse to update in case it exists.
     */
    where: StudentToCourseWhereUniqueInput
    /**
     * In case the StudentToCourse found by the `where` argument doesn't exist, create a new StudentToCourse with this data.
     */
    create: XOR<StudentToCourseCreateInput, StudentToCourseUncheckedCreateInput>
    /**
     * In case the StudentToCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentToCourseUpdateInput, StudentToCourseUncheckedUpdateInput>
  }


  /**
   * StudentToCourse delete
   */
  export type StudentToCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
    /**
     * Filter which StudentToCourse to delete.
     */
    where: StudentToCourseWhereUniqueInput
  }


  /**
   * StudentToCourse deleteMany
   */
  export type StudentToCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentToCourses to delete
     */
    where?: StudentToCourseWhereInput
  }


  /**
   * StudentToCourse without action
   */
  export type StudentToCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentToCourse
     */
    select?: StudentToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StudentToCourseInclude<ExtArgs> | null
  }



  /**
   * Model Teachers
   */

  export type AggregateTeachers = {
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  export type TeachersAvgAggregateOutputType = {
    user_ident: number | null
  }

  export type TeachersSumAggregateOutputType = {
    user_ident: number | null
  }

  export type TeachersMinAggregateOutputType = {
    user_ident: number | null
    fio: string | null
    email: string | null
    user_password: string | null
    descipline: string | null
  }

  export type TeachersMaxAggregateOutputType = {
    user_ident: number | null
    fio: string | null
    email: string | null
    user_password: string | null
    descipline: string | null
  }

  export type TeachersCountAggregateOutputType = {
    user_ident: number
    fio: number
    email: number
    user_password: number
    descipline: number
    _all: number
  }


  export type TeachersAvgAggregateInputType = {
    user_ident?: true
  }

  export type TeachersSumAggregateInputType = {
    user_ident?: true
  }

  export type TeachersMinAggregateInputType = {
    user_ident?: true
    fio?: true
    email?: true
    user_password?: true
    descipline?: true
  }

  export type TeachersMaxAggregateInputType = {
    user_ident?: true
    fio?: true
    email?: true
    user_password?: true
    descipline?: true
  }

  export type TeachersCountAggregateInputType = {
    user_ident?: true
    fio?: true
    email?: true
    user_password?: true
    descipline?: true
    _all?: true
  }

  export type TeachersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to aggregate.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeachersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeachersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeachersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachersMaxAggregateInputType
  }

  export type GetTeachersAggregateType<T extends TeachersAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachers[P]>
      : GetScalarType<T[P], AggregateTeachers[P]>
  }




  export type TeachersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeachersWhereInput
    orderBy?: TeachersOrderByWithAggregationInput | TeachersOrderByWithAggregationInput[]
    by: TeachersScalarFieldEnum[] | TeachersScalarFieldEnum
    having?: TeachersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachersCountAggregateInputType | true
    _avg?: TeachersAvgAggregateInputType
    _sum?: TeachersSumAggregateInputType
    _min?: TeachersMinAggregateInputType
    _max?: TeachersMaxAggregateInputType
  }

  export type TeachersGroupByOutputType = {
    user_ident: number
    fio: string
    email: string
    user_password: string
    descipline: string
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  type GetTeachersGroupByPayload<T extends TeachersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachersGroupByOutputType[P]>
            : GetScalarType<T[P], TeachersGroupByOutputType[P]>
        }
      >
    >


  export type TeachersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_ident?: boolean
    fio?: boolean
    email?: boolean
    user_password?: boolean
    descipline?: boolean
    Desciplines?: boolean | DesciplinesDefaultArgs<ExtArgs>
    TeacherToCourse?: boolean | Teachers$TeacherToCourseArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type TeachersSelectScalar = {
    user_ident?: boolean
    fio?: boolean
    email?: boolean
    user_password?: boolean
    descipline?: boolean
  }

  export type TeachersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Desciplines?: boolean | DesciplinesDefaultArgs<ExtArgs>
    TeacherToCourse?: boolean | Teachers$TeacherToCourseArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TeachersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teachers"
    objects: {
      Desciplines: Prisma.$DesciplinesPayload<ExtArgs>
      TeacherToCourse: Prisma.$TeacherToCoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_ident: number
      fio: string
      email: string
      user_password: string
      descipline: string
    }, ExtArgs["result"]["teachers"]>
    composites: {}
  }


  type TeachersGetPayload<S extends boolean | null | undefined | TeachersDefaultArgs> = $Result.GetResult<Prisma.$TeachersPayload, S>

  type TeachersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeachersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeachersCountAggregateInputType | true
    }

  export interface TeachersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teachers'], meta: { name: 'Teachers' } }
    /**
     * Find zero or one Teachers that matches the filter.
     * @param {TeachersFindUniqueArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeachersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TeachersFindUniqueArgs<ExtArgs>>
    ): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Teachers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeachersFindUniqueOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeachersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeachersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersFindFirstArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeachersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TeachersFindFirstArgs<ExtArgs>>
    ): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Teachers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersFindFirstOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeachersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeachersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teachers.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teachers.findMany({ take: 10 })
     * 
     * // Only select the `user_ident`
     * const teachersWithUser_identOnly = await prisma.teachers.findMany({ select: { user_ident: true } })
     * 
    **/
    findMany<T extends TeachersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeachersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Teachers.
     * @param {TeachersCreateArgs} args - Arguments to create a Teachers.
     * @example
     * // Create one Teachers
     * const Teachers = await prisma.teachers.create({
     *   data: {
     *     // ... data to create a Teachers
     *   }
     * })
     * 
    **/
    create<T extends TeachersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeachersCreateArgs<ExtArgs>>
    ): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Teachers.
     *     @param {TeachersCreateManyArgs} args - Arguments to create many Teachers.
     *     @example
     *     // Create many Teachers
     *     const teachers = await prisma.teachers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeachersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeachersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teachers.
     * @param {TeachersDeleteArgs} args - Arguments to delete one Teachers.
     * @example
     * // Delete one Teachers
     * const Teachers = await prisma.teachers.delete({
     *   where: {
     *     // ... filter to delete one Teachers
     *   }
     * })
     * 
    **/
    delete<T extends TeachersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeachersDeleteArgs<ExtArgs>>
    ): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Teachers.
     * @param {TeachersUpdateArgs} args - Arguments to update one Teachers.
     * @example
     * // Update one Teachers
     * const teachers = await prisma.teachers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeachersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeachersUpdateArgs<ExtArgs>>
    ): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Teachers.
     * @param {TeachersDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teachers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeachersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeachersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeachersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeachersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teachers.
     * @param {TeachersUpsertArgs} args - Arguments to update or create a Teachers.
     * @example
     * // Update or create a Teachers
     * const teachers = await prisma.teachers.upsert({
     *   create: {
     *     // ... data to create a Teachers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teachers we want to update
     *   }
     * })
    **/
    upsert<T extends TeachersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeachersUpsertArgs<ExtArgs>>
    ): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teachers.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeachersCountArgs>(
      args?: Subset<T, TeachersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachersAggregateArgs>(args: Subset<T, TeachersAggregateArgs>): Prisma.PrismaPromise<GetTeachersAggregateType<T>>

    /**
     * Group by Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeachersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeachersGroupByArgs['orderBy'] }
        : { orderBy?: TeachersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeachersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teachers model
   */
  readonly fields: TeachersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teachers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeachersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Desciplines<T extends DesciplinesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DesciplinesDefaultArgs<ExtArgs>>): Prisma__DesciplinesClient<$Result.GetResult<Prisma.$DesciplinesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    TeacherToCourse<T extends Teachers$TeacherToCourseArgs<ExtArgs> = {}>(args?: Subset<T, Teachers$TeacherToCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Teachers model
   */ 
  interface TeachersFieldRefs {
    readonly user_ident: FieldRef<"Teachers", 'Int'>
    readonly fio: FieldRef<"Teachers", 'String'>
    readonly email: FieldRef<"Teachers", 'String'>
    readonly user_password: FieldRef<"Teachers", 'String'>
    readonly descipline: FieldRef<"Teachers", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Teachers findUnique
   */
  export type TeachersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where: TeachersWhereUniqueInput
  }


  /**
   * Teachers findUniqueOrThrow
   */
  export type TeachersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where: TeachersWhereUniqueInput
  }


  /**
   * Teachers findFirst
   */
  export type TeachersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }


  /**
   * Teachers findFirstOrThrow
   */
  export type TeachersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }


  /**
   * Teachers findMany
   */
  export type TeachersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeachersOrderByWithRelationInput | TeachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }


  /**
   * Teachers create
   */
  export type TeachersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * The data needed to create a Teachers.
     */
    data: XOR<TeachersCreateInput, TeachersUncheckedCreateInput>
  }


  /**
   * Teachers createMany
   */
  export type TeachersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeachersCreateManyInput | TeachersCreateManyInput[]
  }


  /**
   * Teachers update
   */
  export type TeachersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * The data needed to update a Teachers.
     */
    data: XOR<TeachersUpdateInput, TeachersUncheckedUpdateInput>
    /**
     * Choose, which Teachers to update.
     */
    where: TeachersWhereUniqueInput
  }


  /**
   * Teachers updateMany
   */
  export type TeachersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeachersUpdateManyMutationInput, TeachersUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeachersWhereInput
  }


  /**
   * Teachers upsert
   */
  export type TeachersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * The filter to search for the Teachers to update in case it exists.
     */
    where: TeachersWhereUniqueInput
    /**
     * In case the Teachers found by the `where` argument doesn't exist, create a new Teachers with this data.
     */
    create: XOR<TeachersCreateInput, TeachersUncheckedCreateInput>
    /**
     * In case the Teachers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeachersUpdateInput, TeachersUncheckedUpdateInput>
  }


  /**
   * Teachers delete
   */
  export type TeachersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
    /**
     * Filter which Teachers to delete.
     */
    where: TeachersWhereUniqueInput
  }


  /**
   * Teachers deleteMany
   */
  export type TeachersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeachersWhereInput
  }


  /**
   * Teachers.TeacherToCourse
   */
  export type Teachers$TeacherToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    where?: TeacherToCourseWhereInput
    orderBy?: TeacherToCourseOrderByWithRelationInput | TeacherToCourseOrderByWithRelationInput[]
    cursor?: TeacherToCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherToCourseScalarFieldEnum | TeacherToCourseScalarFieldEnum[]
  }


  /**
   * Teachers without action
   */
  export type TeachersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teachers
     */
    select?: TeachersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeachersInclude<ExtArgs> | null
  }



  /**
   * Model TeacherToCourse
   */

  export type AggregateTeacherToCourse = {
    _count: TeacherToCourseCountAggregateOutputType | null
    _avg: TeacherToCourseAvgAggregateOutputType | null
    _sum: TeacherToCourseSumAggregateOutputType | null
    _min: TeacherToCourseMinAggregateOutputType | null
    _max: TeacherToCourseMaxAggregateOutputType | null
  }

  export type TeacherToCourseAvgAggregateOutputType = {
    TTC_id: number | null
    teacher_id: number | null
    course_id: number | null
  }

  export type TeacherToCourseSumAggregateOutputType = {
    TTC_id: number | null
    teacher_id: number | null
    course_id: number | null
  }

  export type TeacherToCourseMinAggregateOutputType = {
    TTC_id: number | null
    teacher_id: number | null
    course_id: number | null
  }

  export type TeacherToCourseMaxAggregateOutputType = {
    TTC_id: number | null
    teacher_id: number | null
    course_id: number | null
  }

  export type TeacherToCourseCountAggregateOutputType = {
    TTC_id: number
    teacher_id: number
    course_id: number
    _all: number
  }


  export type TeacherToCourseAvgAggregateInputType = {
    TTC_id?: true
    teacher_id?: true
    course_id?: true
  }

  export type TeacherToCourseSumAggregateInputType = {
    TTC_id?: true
    teacher_id?: true
    course_id?: true
  }

  export type TeacherToCourseMinAggregateInputType = {
    TTC_id?: true
    teacher_id?: true
    course_id?: true
  }

  export type TeacherToCourseMaxAggregateInputType = {
    TTC_id?: true
    teacher_id?: true
    course_id?: true
  }

  export type TeacherToCourseCountAggregateInputType = {
    TTC_id?: true
    teacher_id?: true
    course_id?: true
    _all?: true
  }

  export type TeacherToCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherToCourse to aggregate.
     */
    where?: TeacherToCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherToCourses to fetch.
     */
    orderBy?: TeacherToCourseOrderByWithRelationInput | TeacherToCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherToCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherToCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherToCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherToCourses
    **/
    _count?: true | TeacherToCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherToCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherToCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherToCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherToCourseMaxAggregateInputType
  }

  export type GetTeacherToCourseAggregateType<T extends TeacherToCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherToCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherToCourse[P]>
      : GetScalarType<T[P], AggregateTeacherToCourse[P]>
  }




  export type TeacherToCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherToCourseWhereInput
    orderBy?: TeacherToCourseOrderByWithAggregationInput | TeacherToCourseOrderByWithAggregationInput[]
    by: TeacherToCourseScalarFieldEnum[] | TeacherToCourseScalarFieldEnum
    having?: TeacherToCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherToCourseCountAggregateInputType | true
    _avg?: TeacherToCourseAvgAggregateInputType
    _sum?: TeacherToCourseSumAggregateInputType
    _min?: TeacherToCourseMinAggregateInputType
    _max?: TeacherToCourseMaxAggregateInputType
  }

  export type TeacherToCourseGroupByOutputType = {
    TTC_id: number
    teacher_id: number
    course_id: number
    _count: TeacherToCourseCountAggregateOutputType | null
    _avg: TeacherToCourseAvgAggregateOutputType | null
    _sum: TeacherToCourseSumAggregateOutputType | null
    _min: TeacherToCourseMinAggregateOutputType | null
    _max: TeacherToCourseMaxAggregateOutputType | null
  }

  type GetTeacherToCourseGroupByPayload<T extends TeacherToCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherToCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherToCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherToCourseGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherToCourseGroupByOutputType[P]>
        }
      >
    >


  export type TeacherToCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TTC_id?: boolean
    teacher_id?: boolean
    course_id?: boolean
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Teachers?: boolean | TeachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherToCourse"]>

  export type TeacherToCourseSelectScalar = {
    TTC_id?: boolean
    teacher_id?: boolean
    course_id?: boolean
  }

  export type TeacherToCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    Teachers?: boolean | TeachersDefaultArgs<ExtArgs>
  }


  export type $TeacherToCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherToCourse"
    objects: {
      Courses: Prisma.$CoursesPayload<ExtArgs>
      Teachers: Prisma.$TeachersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      TTC_id: number
      teacher_id: number
      course_id: number
    }, ExtArgs["result"]["teacherToCourse"]>
    composites: {}
  }


  type TeacherToCourseGetPayload<S extends boolean | null | undefined | TeacherToCourseDefaultArgs> = $Result.GetResult<Prisma.$TeacherToCoursePayload, S>

  type TeacherToCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherToCourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherToCourseCountAggregateInputType | true
    }

  export interface TeacherToCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherToCourse'], meta: { name: 'TeacherToCourse' } }
    /**
     * Find zero or one TeacherToCourse that matches the filter.
     * @param {TeacherToCourseFindUniqueArgs} args - Arguments to find a TeacherToCourse
     * @example
     * // Get one TeacherToCourse
     * const teacherToCourse = await prisma.teacherToCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeacherToCourseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherToCourseFindUniqueArgs<ExtArgs>>
    ): Prisma__TeacherToCourseClient<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TeacherToCourse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeacherToCourseFindUniqueOrThrowArgs} args - Arguments to find a TeacherToCourse
     * @example
     * // Get one TeacherToCourse
     * const teacherToCourse = await prisma.teacherToCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeacherToCourseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherToCourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherToCourseClient<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TeacherToCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherToCourseFindFirstArgs} args - Arguments to find a TeacherToCourse
     * @example
     * // Get one TeacherToCourse
     * const teacherToCourse = await prisma.teacherToCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeacherToCourseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherToCourseFindFirstArgs<ExtArgs>>
    ): Prisma__TeacherToCourseClient<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TeacherToCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherToCourseFindFirstOrThrowArgs} args - Arguments to find a TeacherToCourse
     * @example
     * // Get one TeacherToCourse
     * const teacherToCourse = await prisma.teacherToCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeacherToCourseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherToCourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeacherToCourseClient<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TeacherToCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherToCourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherToCourses
     * const teacherToCourses = await prisma.teacherToCourse.findMany()
     * 
     * // Get first 10 TeacherToCourses
     * const teacherToCourses = await prisma.teacherToCourse.findMany({ take: 10 })
     * 
     * // Only select the `TTC_id`
     * const teacherToCourseWithTTC_idOnly = await prisma.teacherToCourse.findMany({ select: { TTC_id: true } })
     * 
    **/
    findMany<T extends TeacherToCourseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherToCourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TeacherToCourse.
     * @param {TeacherToCourseCreateArgs} args - Arguments to create a TeacherToCourse.
     * @example
     * // Create one TeacherToCourse
     * const TeacherToCourse = await prisma.teacherToCourse.create({
     *   data: {
     *     // ... data to create a TeacherToCourse
     *   }
     * })
     * 
    **/
    create<T extends TeacherToCourseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherToCourseCreateArgs<ExtArgs>>
    ): Prisma__TeacherToCourseClient<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TeacherToCourses.
     *     @param {TeacherToCourseCreateManyArgs} args - Arguments to create many TeacherToCourses.
     *     @example
     *     // Create many TeacherToCourses
     *     const teacherToCourse = await prisma.teacherToCourse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeacherToCourseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherToCourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherToCourse.
     * @param {TeacherToCourseDeleteArgs} args - Arguments to delete one TeacherToCourse.
     * @example
     * // Delete one TeacherToCourse
     * const TeacherToCourse = await prisma.teacherToCourse.delete({
     *   where: {
     *     // ... filter to delete one TeacherToCourse
     *   }
     * })
     * 
    **/
    delete<T extends TeacherToCourseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherToCourseDeleteArgs<ExtArgs>>
    ): Prisma__TeacherToCourseClient<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TeacherToCourse.
     * @param {TeacherToCourseUpdateArgs} args - Arguments to update one TeacherToCourse.
     * @example
     * // Update one TeacherToCourse
     * const teacherToCourse = await prisma.teacherToCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeacherToCourseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherToCourseUpdateArgs<ExtArgs>>
    ): Prisma__TeacherToCourseClient<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TeacherToCourses.
     * @param {TeacherToCourseDeleteManyArgs} args - Arguments to filter TeacherToCourses to delete.
     * @example
     * // Delete a few TeacherToCourses
     * const { count } = await prisma.teacherToCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeacherToCourseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeacherToCourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherToCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherToCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherToCourses
     * const teacherToCourse = await prisma.teacherToCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeacherToCourseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherToCourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherToCourse.
     * @param {TeacherToCourseUpsertArgs} args - Arguments to update or create a TeacherToCourse.
     * @example
     * // Update or create a TeacherToCourse
     * const teacherToCourse = await prisma.teacherToCourse.upsert({
     *   create: {
     *     // ... data to create a TeacherToCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherToCourse we want to update
     *   }
     * })
    **/
    upsert<T extends TeacherToCourseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeacherToCourseUpsertArgs<ExtArgs>>
    ): Prisma__TeacherToCourseClient<$Result.GetResult<Prisma.$TeacherToCoursePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TeacherToCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherToCourseCountArgs} args - Arguments to filter TeacherToCourses to count.
     * @example
     * // Count the number of TeacherToCourses
     * const count = await prisma.teacherToCourse.count({
     *   where: {
     *     // ... the filter for the TeacherToCourses we want to count
     *   }
     * })
    **/
    count<T extends TeacherToCourseCountArgs>(
      args?: Subset<T, TeacherToCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherToCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherToCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherToCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherToCourseAggregateArgs>(args: Subset<T, TeacherToCourseAggregateArgs>): Prisma.PrismaPromise<GetTeacherToCourseAggregateType<T>>

    /**
     * Group by TeacherToCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherToCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherToCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherToCourseGroupByArgs['orderBy'] }
        : { orderBy?: TeacherToCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherToCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherToCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherToCourse model
   */
  readonly fields: TeacherToCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherToCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherToCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Teachers<T extends TeachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeachersDefaultArgs<ExtArgs>>): Prisma__TeachersClient<$Result.GetResult<Prisma.$TeachersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TeacherToCourse model
   */ 
  interface TeacherToCourseFieldRefs {
    readonly TTC_id: FieldRef<"TeacherToCourse", 'Int'>
    readonly teacher_id: FieldRef<"TeacherToCourse", 'Int'>
    readonly course_id: FieldRef<"TeacherToCourse", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TeacherToCourse findUnique
   */
  export type TeacherToCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    /**
     * Filter, which TeacherToCourse to fetch.
     */
    where: TeacherToCourseWhereUniqueInput
  }


  /**
   * TeacherToCourse findUniqueOrThrow
   */
  export type TeacherToCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    /**
     * Filter, which TeacherToCourse to fetch.
     */
    where: TeacherToCourseWhereUniqueInput
  }


  /**
   * TeacherToCourse findFirst
   */
  export type TeacherToCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    /**
     * Filter, which TeacherToCourse to fetch.
     */
    where?: TeacherToCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherToCourses to fetch.
     */
    orderBy?: TeacherToCourseOrderByWithRelationInput | TeacherToCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherToCourses.
     */
    cursor?: TeacherToCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherToCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherToCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherToCourses.
     */
    distinct?: TeacherToCourseScalarFieldEnum | TeacherToCourseScalarFieldEnum[]
  }


  /**
   * TeacherToCourse findFirstOrThrow
   */
  export type TeacherToCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    /**
     * Filter, which TeacherToCourse to fetch.
     */
    where?: TeacherToCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherToCourses to fetch.
     */
    orderBy?: TeacherToCourseOrderByWithRelationInput | TeacherToCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherToCourses.
     */
    cursor?: TeacherToCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherToCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherToCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherToCourses.
     */
    distinct?: TeacherToCourseScalarFieldEnum | TeacherToCourseScalarFieldEnum[]
  }


  /**
   * TeacherToCourse findMany
   */
  export type TeacherToCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    /**
     * Filter, which TeacherToCourses to fetch.
     */
    where?: TeacherToCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherToCourses to fetch.
     */
    orderBy?: TeacherToCourseOrderByWithRelationInput | TeacherToCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherToCourses.
     */
    cursor?: TeacherToCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherToCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherToCourses.
     */
    skip?: number
    distinct?: TeacherToCourseScalarFieldEnum | TeacherToCourseScalarFieldEnum[]
  }


  /**
   * TeacherToCourse create
   */
  export type TeacherToCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherToCourse.
     */
    data: XOR<TeacherToCourseCreateInput, TeacherToCourseUncheckedCreateInput>
  }


  /**
   * TeacherToCourse createMany
   */
  export type TeacherToCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherToCourses.
     */
    data: TeacherToCourseCreateManyInput | TeacherToCourseCreateManyInput[]
  }


  /**
   * TeacherToCourse update
   */
  export type TeacherToCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherToCourse.
     */
    data: XOR<TeacherToCourseUpdateInput, TeacherToCourseUncheckedUpdateInput>
    /**
     * Choose, which TeacherToCourse to update.
     */
    where: TeacherToCourseWhereUniqueInput
  }


  /**
   * TeacherToCourse updateMany
   */
  export type TeacherToCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherToCourses.
     */
    data: XOR<TeacherToCourseUpdateManyMutationInput, TeacherToCourseUncheckedUpdateManyInput>
    /**
     * Filter which TeacherToCourses to update
     */
    where?: TeacherToCourseWhereInput
  }


  /**
   * TeacherToCourse upsert
   */
  export type TeacherToCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherToCourse to update in case it exists.
     */
    where: TeacherToCourseWhereUniqueInput
    /**
     * In case the TeacherToCourse found by the `where` argument doesn't exist, create a new TeacherToCourse with this data.
     */
    create: XOR<TeacherToCourseCreateInput, TeacherToCourseUncheckedCreateInput>
    /**
     * In case the TeacherToCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherToCourseUpdateInput, TeacherToCourseUncheckedUpdateInput>
  }


  /**
   * TeacherToCourse delete
   */
  export type TeacherToCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
    /**
     * Filter which TeacherToCourse to delete.
     */
    where: TeacherToCourseWhereUniqueInput
  }


  /**
   * TeacherToCourse deleteMany
   */
  export type TeacherToCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherToCourses to delete
     */
    where?: TeacherToCourseWhereInput
  }


  /**
   * TeacherToCourse without action
   */
  export type TeacherToCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherToCourse
     */
    select?: TeacherToCourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeacherToCourseInclude<ExtArgs> | null
  }



  /**
   * Model Tests
   */

  export type AggregateTests = {
    _count: TestsCountAggregateOutputType | null
    _avg: TestsAvgAggregateOutputType | null
    _sum: TestsSumAggregateOutputType | null
    _min: TestsMinAggregateOutputType | null
    _max: TestsMaxAggregateOutputType | null
  }

  export type TestsAvgAggregateOutputType = {
    test_id: number | null
    course_id: number | null
  }

  export type TestsSumAggregateOutputType = {
    test_id: number | null
    course_id: number | null
  }

  export type TestsMinAggregateOutputType = {
    test_id: number | null
    test_name: string | null
    test_desc: string | null
    course_id: number | null
  }

  export type TestsMaxAggregateOutputType = {
    test_id: number | null
    test_name: string | null
    test_desc: string | null
    course_id: number | null
  }

  export type TestsCountAggregateOutputType = {
    test_id: number
    test_name: number
    test_desc: number
    course_id: number
    _all: number
  }


  export type TestsAvgAggregateInputType = {
    test_id?: true
    course_id?: true
  }

  export type TestsSumAggregateInputType = {
    test_id?: true
    course_id?: true
  }

  export type TestsMinAggregateInputType = {
    test_id?: true
    test_name?: true
    test_desc?: true
    course_id?: true
  }

  export type TestsMaxAggregateInputType = {
    test_id?: true
    test_name?: true
    test_desc?: true
    course_id?: true
  }

  export type TestsCountAggregateInputType = {
    test_id?: true
    test_name?: true
    test_desc?: true
    course_id?: true
    _all?: true
  }

  export type TestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tests to aggregate.
     */
    where?: TestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestsOrderByWithRelationInput | TestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tests
    **/
    _count?: true | TestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestsMaxAggregateInputType
  }

  export type GetTestsAggregateType<T extends TestsAggregateArgs> = {
        [P in keyof T & keyof AggregateTests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTests[P]>
      : GetScalarType<T[P], AggregateTests[P]>
  }




  export type TestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestsWhereInput
    orderBy?: TestsOrderByWithAggregationInput | TestsOrderByWithAggregationInput[]
    by: TestsScalarFieldEnum[] | TestsScalarFieldEnum
    having?: TestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestsCountAggregateInputType | true
    _avg?: TestsAvgAggregateInputType
    _sum?: TestsSumAggregateInputType
    _min?: TestsMinAggregateInputType
    _max?: TestsMaxAggregateInputType
  }

  export type TestsGroupByOutputType = {
    test_id: number
    test_name: string
    test_desc: string
    course_id: number
    _count: TestsCountAggregateOutputType | null
    _avg: TestsAvgAggregateOutputType | null
    _sum: TestsSumAggregateOutputType | null
    _min: TestsMinAggregateOutputType | null
    _max: TestsMaxAggregateOutputType | null
  }

  type GetTestsGroupByPayload<T extends TestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestsGroupByOutputType[P]>
            : GetScalarType<T[P], TestsGroupByOutputType[P]>
        }
      >
    >


  export type TestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    test_id?: boolean
    test_name?: boolean
    test_desc?: boolean
    course_id?: boolean
    Answers?: boolean | Tests$AnswersArgs<ExtArgs>
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    TestStatus?: boolean | Tests$TestStatusArgs<ExtArgs>
    _count?: boolean | TestsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tests"]>

  export type TestsSelectScalar = {
    test_id?: boolean
    test_name?: boolean
    test_desc?: boolean
    course_id?: boolean
  }

  export type TestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Answers?: boolean | Tests$AnswersArgs<ExtArgs>
    Courses?: boolean | CoursesDefaultArgs<ExtArgs>
    TestStatus?: boolean | Tests$TestStatusArgs<ExtArgs>
    _count?: boolean | TestsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tests"
    objects: {
      Answers: Prisma.$AnswersPayload<ExtArgs>[]
      Courses: Prisma.$CoursesPayload<ExtArgs>
      TestStatus: Prisma.$TestStatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      test_id: number
      test_name: string
      test_desc: string
      course_id: number
    }, ExtArgs["result"]["tests"]>
    composites: {}
  }


  type TestsGetPayload<S extends boolean | null | undefined | TestsDefaultArgs> = $Result.GetResult<Prisma.$TestsPayload, S>

  type TestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestsCountAggregateInputType | true
    }

  export interface TestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tests'], meta: { name: 'Tests' } }
    /**
     * Find zero or one Tests that matches the filter.
     * @param {TestsFindUniqueArgs} args - Arguments to find a Tests
     * @example
     * // Get one Tests
     * const tests = await prisma.tests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TestsFindUniqueArgs<ExtArgs>>
    ): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tests that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TestsFindUniqueOrThrowArgs} args - Arguments to find a Tests
     * @example
     * // Get one Tests
     * const tests = await prisma.tests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TestsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestsFindFirstArgs} args - Arguments to find a Tests
     * @example
     * // Get one Tests
     * const tests = await prisma.tests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TestsFindFirstArgs<ExtArgs>>
    ): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestsFindFirstOrThrowArgs} args - Arguments to find a Tests
     * @example
     * // Get one Tests
     * const tests = await prisma.tests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TestsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tests
     * const tests = await prisma.tests.findMany()
     * 
     * // Get first 10 Tests
     * const tests = await prisma.tests.findMany({ take: 10 })
     * 
     * // Only select the `test_id`
     * const testsWithTest_idOnly = await prisma.tests.findMany({ select: { test_id: true } })
     * 
    **/
    findMany<T extends TestsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tests.
     * @param {TestsCreateArgs} args - Arguments to create a Tests.
     * @example
     * // Create one Tests
     * const Tests = await prisma.tests.create({
     *   data: {
     *     // ... data to create a Tests
     *   }
     * })
     * 
    **/
    create<T extends TestsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TestsCreateArgs<ExtArgs>>
    ): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tests.
     *     @param {TestsCreateManyArgs} args - Arguments to create many Tests.
     *     @example
     *     // Create many Tests
     *     const tests = await prisma.tests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tests.
     * @param {TestsDeleteArgs} args - Arguments to delete one Tests.
     * @example
     * // Delete one Tests
     * const Tests = await prisma.tests.delete({
     *   where: {
     *     // ... filter to delete one Tests
     *   }
     * })
     * 
    **/
    delete<T extends TestsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TestsDeleteArgs<ExtArgs>>
    ): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tests.
     * @param {TestsUpdateArgs} args - Arguments to update one Tests.
     * @example
     * // Update one Tests
     * const tests = await prisma.tests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TestsUpdateArgs<ExtArgs>>
    ): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tests.
     * @param {TestsDeleteManyArgs} args - Arguments to filter Tests to delete.
     * @example
     * // Delete a few Tests
     * const { count } = await prisma.tests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tests
     * const tests = await prisma.tests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TestsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tests.
     * @param {TestsUpsertArgs} args - Arguments to update or create a Tests.
     * @example
     * // Update or create a Tests
     * const tests = await prisma.tests.upsert({
     *   create: {
     *     // ... data to create a Tests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tests we want to update
     *   }
     * })
    **/
    upsert<T extends TestsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TestsUpsertArgs<ExtArgs>>
    ): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestsCountArgs} args - Arguments to filter Tests to count.
     * @example
     * // Count the number of Tests
     * const count = await prisma.tests.count({
     *   where: {
     *     // ... the filter for the Tests we want to count
     *   }
     * })
    **/
    count<T extends TestsCountArgs>(
      args?: Subset<T, TestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestsAggregateArgs>(args: Subset<T, TestsAggregateArgs>): Prisma.PrismaPromise<GetTestsAggregateType<T>>

    /**
     * Group by Tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestsGroupByArgs['orderBy'] }
        : { orderBy?: TestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tests model
   */
  readonly fields: TestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Answers<T extends Tests$AnswersArgs<ExtArgs> = {}>(args?: Subset<T, Tests$AnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswersPayload<ExtArgs>, T, 'findMany'> | Null>;

    Courses<T extends CoursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoursesDefaultArgs<ExtArgs>>): Prisma__CoursesClient<$Result.GetResult<Prisma.$CoursesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    TestStatus<T extends Tests$TestStatusArgs<ExtArgs> = {}>(args?: Subset<T, Tests$TestStatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tests model
   */ 
  interface TestsFieldRefs {
    readonly test_id: FieldRef<"Tests", 'Int'>
    readonly test_name: FieldRef<"Tests", 'String'>
    readonly test_desc: FieldRef<"Tests", 'String'>
    readonly course_id: FieldRef<"Tests", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Tests findUnique
   */
  export type TestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where: TestsWhereUniqueInput
  }


  /**
   * Tests findUniqueOrThrow
   */
  export type TestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where: TestsWhereUniqueInput
  }


  /**
   * Tests findFirst
   */
  export type TestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestsOrderByWithRelationInput | TestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestsScalarFieldEnum | TestsScalarFieldEnum[]
  }


  /**
   * Tests findFirstOrThrow
   */
  export type TestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestsOrderByWithRelationInput | TestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tests.
     */
    cursor?: TestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tests.
     */
    distinct?: TestsScalarFieldEnum | TestsScalarFieldEnum[]
  }


  /**
   * Tests findMany
   */
  export type TestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    /**
     * Filter, which Tests to fetch.
     */
    where?: TestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tests to fetch.
     */
    orderBy?: TestsOrderByWithRelationInput | TestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tests.
     */
    cursor?: TestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tests.
     */
    skip?: number
    distinct?: TestsScalarFieldEnum | TestsScalarFieldEnum[]
  }


  /**
   * Tests create
   */
  export type TestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tests.
     */
    data: XOR<TestsCreateInput, TestsUncheckedCreateInput>
  }


  /**
   * Tests createMany
   */
  export type TestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tests.
     */
    data: TestsCreateManyInput | TestsCreateManyInput[]
  }


  /**
   * Tests update
   */
  export type TestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tests.
     */
    data: XOR<TestsUpdateInput, TestsUncheckedUpdateInput>
    /**
     * Choose, which Tests to update.
     */
    where: TestsWhereUniqueInput
  }


  /**
   * Tests updateMany
   */
  export type TestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tests.
     */
    data: XOR<TestsUpdateManyMutationInput, TestsUncheckedUpdateManyInput>
    /**
     * Filter which Tests to update
     */
    where?: TestsWhereInput
  }


  /**
   * Tests upsert
   */
  export type TestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tests to update in case it exists.
     */
    where: TestsWhereUniqueInput
    /**
     * In case the Tests found by the `where` argument doesn't exist, create a new Tests with this data.
     */
    create: XOR<TestsCreateInput, TestsUncheckedCreateInput>
    /**
     * In case the Tests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestsUpdateInput, TestsUncheckedUpdateInput>
  }


  /**
   * Tests delete
   */
  export type TestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
    /**
     * Filter which Tests to delete.
     */
    where: TestsWhereUniqueInput
  }


  /**
   * Tests deleteMany
   */
  export type TestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tests to delete
     */
    where?: TestsWhereInput
  }


  /**
   * Tests.Answers
   */
  export type Tests$AnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answers
     */
    select?: AnswersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswersInclude<ExtArgs> | null
    where?: AnswersWhereInput
    orderBy?: AnswersOrderByWithRelationInput | AnswersOrderByWithRelationInput[]
    cursor?: AnswersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }


  /**
   * Tests.TestStatus
   */
  export type Tests$TestStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    where?: TestStatusWhereInput
    orderBy?: TestStatusOrderByWithRelationInput | TestStatusOrderByWithRelationInput[]
    cursor?: TestStatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestStatusScalarFieldEnum | TestStatusScalarFieldEnum[]
  }


  /**
   * Tests without action
   */
  export type TestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tests
     */
    select?: TestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestsInclude<ExtArgs> | null
  }



  /**
   * Model TestStatus
   */

  export type AggregateTestStatus = {
    _count: TestStatusCountAggregateOutputType | null
    _avg: TestStatusAvgAggregateOutputType | null
    _sum: TestStatusSumAggregateOutputType | null
    _min: TestStatusMinAggregateOutputType | null
    _max: TestStatusMaxAggregateOutputType | null
  }

  export type TestStatusAvgAggregateOutputType = {
    status_id: number | null
    test_id: number | null
    student_id: number | null
  }

  export type TestStatusSumAggregateOutputType = {
    status_id: number | null
    test_id: number | null
    student_id: number | null
  }

  export type TestStatusMinAggregateOutputType = {
    status_id: number | null
    test_id: number | null
    student_id: number | null
  }

  export type TestStatusMaxAggregateOutputType = {
    status_id: number | null
    test_id: number | null
    student_id: number | null
  }

  export type TestStatusCountAggregateOutputType = {
    status_id: number
    test_id: number
    student_id: number
    _all: number
  }


  export type TestStatusAvgAggregateInputType = {
    status_id?: true
    test_id?: true
    student_id?: true
  }

  export type TestStatusSumAggregateInputType = {
    status_id?: true
    test_id?: true
    student_id?: true
  }

  export type TestStatusMinAggregateInputType = {
    status_id?: true
    test_id?: true
    student_id?: true
  }

  export type TestStatusMaxAggregateInputType = {
    status_id?: true
    test_id?: true
    student_id?: true
  }

  export type TestStatusCountAggregateInputType = {
    status_id?: true
    test_id?: true
    student_id?: true
    _all?: true
  }

  export type TestStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestStatus to aggregate.
     */
    where?: TestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestStatuses to fetch.
     */
    orderBy?: TestStatusOrderByWithRelationInput | TestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestStatuses
    **/
    _count?: true | TestStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestStatusMaxAggregateInputType
  }

  export type GetTestStatusAggregateType<T extends TestStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTestStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestStatus[P]>
      : GetScalarType<T[P], AggregateTestStatus[P]>
  }




  export type TestStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestStatusWhereInput
    orderBy?: TestStatusOrderByWithAggregationInput | TestStatusOrderByWithAggregationInput[]
    by: TestStatusScalarFieldEnum[] | TestStatusScalarFieldEnum
    having?: TestStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestStatusCountAggregateInputType | true
    _avg?: TestStatusAvgAggregateInputType
    _sum?: TestStatusSumAggregateInputType
    _min?: TestStatusMinAggregateInputType
    _max?: TestStatusMaxAggregateInputType
  }

  export type TestStatusGroupByOutputType = {
    status_id: number
    test_id: number
    student_id: number
    _count: TestStatusCountAggregateOutputType | null
    _avg: TestStatusAvgAggregateOutputType | null
    _sum: TestStatusSumAggregateOutputType | null
    _min: TestStatusMinAggregateOutputType | null
    _max: TestStatusMaxAggregateOutputType | null
  }

  type GetTestStatusGroupByPayload<T extends TestStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestStatusGroupByOutputType[P]>
            : GetScalarType<T[P], TestStatusGroupByOutputType[P]>
        }
      >
    >


  export type TestStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    test_id?: boolean
    student_id?: boolean
    Students?: boolean | StudentsDefaultArgs<ExtArgs>
    Tests?: boolean | TestsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testStatus"]>

  export type TestStatusSelectScalar = {
    status_id?: boolean
    test_id?: boolean
    student_id?: boolean
  }

  export type TestStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Students?: boolean | StudentsDefaultArgs<ExtArgs>
    Tests?: boolean | TestsDefaultArgs<ExtArgs>
  }


  export type $TestStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestStatus"
    objects: {
      Students: Prisma.$StudentsPayload<ExtArgs>
      Tests: Prisma.$TestsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      status_id: number
      test_id: number
      student_id: number
    }, ExtArgs["result"]["testStatus"]>
    composites: {}
  }


  type TestStatusGetPayload<S extends boolean | null | undefined | TestStatusDefaultArgs> = $Result.GetResult<Prisma.$TestStatusPayload, S>

  type TestStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TestStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TestStatusCountAggregateInputType | true
    }

  export interface TestStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestStatus'], meta: { name: 'TestStatus' } }
    /**
     * Find zero or one TestStatus that matches the filter.
     * @param {TestStatusFindUniqueArgs} args - Arguments to find a TestStatus
     * @example
     * // Get one TestStatus
     * const testStatus = await prisma.testStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TestStatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TestStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__TestStatusClient<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TestStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TestStatusFindUniqueOrThrowArgs} args - Arguments to find a TestStatus
     * @example
     * // Get one TestStatus
     * const testStatus = await prisma.testStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TestStatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TestStatusClient<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TestStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestStatusFindFirstArgs} args - Arguments to find a TestStatus
     * @example
     * // Get one TestStatus
     * const testStatus = await prisma.testStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TestStatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TestStatusFindFirstArgs<ExtArgs>>
    ): Prisma__TestStatusClient<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TestStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestStatusFindFirstOrThrowArgs} args - Arguments to find a TestStatus
     * @example
     * // Get one TestStatus
     * const testStatus = await prisma.testStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TestStatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TestStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TestStatusClient<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TestStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestStatuses
     * const testStatuses = await prisma.testStatus.findMany()
     * 
     * // Get first 10 TestStatuses
     * const testStatuses = await prisma.testStatus.findMany({ take: 10 })
     * 
     * // Only select the `status_id`
     * const testStatusWithStatus_idOnly = await prisma.testStatus.findMany({ select: { status_id: true } })
     * 
    **/
    findMany<T extends TestStatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TestStatus.
     * @param {TestStatusCreateArgs} args - Arguments to create a TestStatus.
     * @example
     * // Create one TestStatus
     * const TestStatus = await prisma.testStatus.create({
     *   data: {
     *     // ... data to create a TestStatus
     *   }
     * })
     * 
    **/
    create<T extends TestStatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TestStatusCreateArgs<ExtArgs>>
    ): Prisma__TestStatusClient<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TestStatuses.
     *     @param {TestStatusCreateManyArgs} args - Arguments to create many TestStatuses.
     *     @example
     *     // Create many TestStatuses
     *     const testStatus = await prisma.testStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TestStatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestStatus.
     * @param {TestStatusDeleteArgs} args - Arguments to delete one TestStatus.
     * @example
     * // Delete one TestStatus
     * const TestStatus = await prisma.testStatus.delete({
     *   where: {
     *     // ... filter to delete one TestStatus
     *   }
     * })
     * 
    **/
    delete<T extends TestStatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TestStatusDeleteArgs<ExtArgs>>
    ): Prisma__TestStatusClient<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TestStatus.
     * @param {TestStatusUpdateArgs} args - Arguments to update one TestStatus.
     * @example
     * // Update one TestStatus
     * const testStatus = await prisma.testStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TestStatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TestStatusUpdateArgs<ExtArgs>>
    ): Prisma__TestStatusClient<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TestStatuses.
     * @param {TestStatusDeleteManyArgs} args - Arguments to filter TestStatuses to delete.
     * @example
     * // Delete a few TestStatuses
     * const { count } = await prisma.testStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TestStatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TestStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestStatuses
     * const testStatus = await prisma.testStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TestStatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TestStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestStatus.
     * @param {TestStatusUpsertArgs} args - Arguments to update or create a TestStatus.
     * @example
     * // Update or create a TestStatus
     * const testStatus = await prisma.testStatus.upsert({
     *   create: {
     *     // ... data to create a TestStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestStatus we want to update
     *   }
     * })
    **/
    upsert<T extends TestStatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TestStatusUpsertArgs<ExtArgs>>
    ): Prisma__TestStatusClient<$Result.GetResult<Prisma.$TestStatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TestStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestStatusCountArgs} args - Arguments to filter TestStatuses to count.
     * @example
     * // Count the number of TestStatuses
     * const count = await prisma.testStatus.count({
     *   where: {
     *     // ... the filter for the TestStatuses we want to count
     *   }
     * })
    **/
    count<T extends TestStatusCountArgs>(
      args?: Subset<T, TestStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestStatusAggregateArgs>(args: Subset<T, TestStatusAggregateArgs>): Prisma.PrismaPromise<GetTestStatusAggregateType<T>>

    /**
     * Group by TestStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestStatusGroupByArgs['orderBy'] }
        : { orderBy?: TestStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestStatus model
   */
  readonly fields: TestStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Students<T extends StudentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentsDefaultArgs<ExtArgs>>): Prisma__StudentsClient<$Result.GetResult<Prisma.$StudentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Tests<T extends TestsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestsDefaultArgs<ExtArgs>>): Prisma__TestsClient<$Result.GetResult<Prisma.$TestsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TestStatus model
   */ 
  interface TestStatusFieldRefs {
    readonly status_id: FieldRef<"TestStatus", 'Int'>
    readonly test_id: FieldRef<"TestStatus", 'Int'>
    readonly student_id: FieldRef<"TestStatus", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * TestStatus findUnique
   */
  export type TestStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    /**
     * Filter, which TestStatus to fetch.
     */
    where: TestStatusWhereUniqueInput
  }


  /**
   * TestStatus findUniqueOrThrow
   */
  export type TestStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    /**
     * Filter, which TestStatus to fetch.
     */
    where: TestStatusWhereUniqueInput
  }


  /**
   * TestStatus findFirst
   */
  export type TestStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    /**
     * Filter, which TestStatus to fetch.
     */
    where?: TestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestStatuses to fetch.
     */
    orderBy?: TestStatusOrderByWithRelationInput | TestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestStatuses.
     */
    cursor?: TestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestStatuses.
     */
    distinct?: TestStatusScalarFieldEnum | TestStatusScalarFieldEnum[]
  }


  /**
   * TestStatus findFirstOrThrow
   */
  export type TestStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    /**
     * Filter, which TestStatus to fetch.
     */
    where?: TestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestStatuses to fetch.
     */
    orderBy?: TestStatusOrderByWithRelationInput | TestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestStatuses.
     */
    cursor?: TestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestStatuses.
     */
    distinct?: TestStatusScalarFieldEnum | TestStatusScalarFieldEnum[]
  }


  /**
   * TestStatus findMany
   */
  export type TestStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    /**
     * Filter, which TestStatuses to fetch.
     */
    where?: TestStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestStatuses to fetch.
     */
    orderBy?: TestStatusOrderByWithRelationInput | TestStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestStatuses.
     */
    cursor?: TestStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestStatuses.
     */
    skip?: number
    distinct?: TestStatusScalarFieldEnum | TestStatusScalarFieldEnum[]
  }


  /**
   * TestStatus create
   */
  export type TestStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a TestStatus.
     */
    data: XOR<TestStatusCreateInput, TestStatusUncheckedCreateInput>
  }


  /**
   * TestStatus createMany
   */
  export type TestStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestStatuses.
     */
    data: TestStatusCreateManyInput | TestStatusCreateManyInput[]
  }


  /**
   * TestStatus update
   */
  export type TestStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a TestStatus.
     */
    data: XOR<TestStatusUpdateInput, TestStatusUncheckedUpdateInput>
    /**
     * Choose, which TestStatus to update.
     */
    where: TestStatusWhereUniqueInput
  }


  /**
   * TestStatus updateMany
   */
  export type TestStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestStatuses.
     */
    data: XOR<TestStatusUpdateManyMutationInput, TestStatusUncheckedUpdateManyInput>
    /**
     * Filter which TestStatuses to update
     */
    where?: TestStatusWhereInput
  }


  /**
   * TestStatus upsert
   */
  export type TestStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the TestStatus to update in case it exists.
     */
    where: TestStatusWhereUniqueInput
    /**
     * In case the TestStatus found by the `where` argument doesn't exist, create a new TestStatus with this data.
     */
    create: XOR<TestStatusCreateInput, TestStatusUncheckedCreateInput>
    /**
     * In case the TestStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestStatusUpdateInput, TestStatusUncheckedUpdateInput>
  }


  /**
   * TestStatus delete
   */
  export type TestStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
    /**
     * Filter which TestStatus to delete.
     */
    where: TestStatusWhereUniqueInput
  }


  /**
   * TestStatus deleteMany
   */
  export type TestStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestStatuses to delete
     */
    where?: TestStatusWhereInput
  }


  /**
   * TestStatus without action
   */
  export type TestStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestStatus
     */
    select?: TestStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TestStatusInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnswersScalarFieldEnum: {
    answer_id: 'answer_id',
    question: 'question',
    answers: 'answers',
    answer_count: 'answer_count',
    answer_right: 'answer_right',
    test_id: 'test_id'
  };

  export type AnswersScalarFieldEnum = (typeof AnswersScalarFieldEnum)[keyof typeof AnswersScalarFieldEnum]


  export const CoursesScalarFieldEnum: {
    course_id: 'course_id',
    course_name: 'course_name',
    course_cost: 'course_cost',
    course_description: 'course_description',
    course_descipline: 'course_descipline'
  };

  export type CoursesScalarFieldEnum = (typeof CoursesScalarFieldEnum)[keyof typeof CoursesScalarFieldEnum]


  export const DesciplinesScalarFieldEnum: {
    descipline_name: 'descipline_name'
  };

  export type DesciplinesScalarFieldEnum = (typeof DesciplinesScalarFieldEnum)[keyof typeof DesciplinesScalarFieldEnum]


  export const MaterialsScalarFieldEnum: {
    material_id: 'material_id',
    material_name: 'material_name',
    course_id: 'course_id',
    material_ingo: 'material_ingo'
  };

  export type MaterialsScalarFieldEnum = (typeof MaterialsScalarFieldEnum)[keyof typeof MaterialsScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    user_ident: 'user_ident',
    fio: 'fio',
    balance: 'balance',
    email: 'email',
    user_password: 'user_password'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const StudentToCourseScalarFieldEnum: {
    STC_id: 'STC_id',
    course_id: 'course_id',
    student_id: 'student_id'
  };

  export type StudentToCourseScalarFieldEnum = (typeof StudentToCourseScalarFieldEnum)[keyof typeof StudentToCourseScalarFieldEnum]


  export const TeachersScalarFieldEnum: {
    user_ident: 'user_ident',
    fio: 'fio',
    email: 'email',
    user_password: 'user_password',
    descipline: 'descipline'
  };

  export type TeachersScalarFieldEnum = (typeof TeachersScalarFieldEnum)[keyof typeof TeachersScalarFieldEnum]


  export const TeacherToCourseScalarFieldEnum: {
    TTC_id: 'TTC_id',
    teacher_id: 'teacher_id',
    course_id: 'course_id'
  };

  export type TeacherToCourseScalarFieldEnum = (typeof TeacherToCourseScalarFieldEnum)[keyof typeof TeacherToCourseScalarFieldEnum]


  export const TestsScalarFieldEnum: {
    test_id: 'test_id',
    test_name: 'test_name',
    test_desc: 'test_desc',
    course_id: 'course_id'
  };

  export type TestsScalarFieldEnum = (typeof TestsScalarFieldEnum)[keyof typeof TestsScalarFieldEnum]


  export const TestStatusScalarFieldEnum: {
    status_id: 'status_id',
    test_id: 'test_id',
    student_id: 'student_id'
  };

  export type TestStatusScalarFieldEnum = (typeof TestStatusScalarFieldEnum)[keyof typeof TestStatusScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AnswersWhereInput = {
    AND?: AnswersWhereInput | AnswersWhereInput[]
    OR?: AnswersWhereInput[]
    NOT?: AnswersWhereInput | AnswersWhereInput[]
    answer_id?: IntFilter<"Answers"> | number
    question?: StringFilter<"Answers"> | string
    answers?: StringFilter<"Answers"> | string
    answer_count?: IntFilter<"Answers"> | number
    answer_right?: IntFilter<"Answers"> | number
    test_id?: IntFilter<"Answers"> | number
    Tests?: XOR<TestsRelationFilter, TestsWhereInput>
  }

  export type AnswersOrderByWithRelationInput = {
    answer_id?: SortOrder
    question?: SortOrder
    answers?: SortOrder
    answer_count?: SortOrder
    answer_right?: SortOrder
    test_id?: SortOrder
    Tests?: TestsOrderByWithRelationInput
  }

  export type AnswersWhereUniqueInput = Prisma.AtLeast<{
    answer_id?: number
    AND?: AnswersWhereInput | AnswersWhereInput[]
    OR?: AnswersWhereInput[]
    NOT?: AnswersWhereInput | AnswersWhereInput[]
    question?: StringFilter<"Answers"> | string
    answers?: StringFilter<"Answers"> | string
    answer_count?: IntFilter<"Answers"> | number
    answer_right?: IntFilter<"Answers"> | number
    test_id?: IntFilter<"Answers"> | number
    Tests?: XOR<TestsRelationFilter, TestsWhereInput>
  }, "answer_id">

  export type AnswersOrderByWithAggregationInput = {
    answer_id?: SortOrder
    question?: SortOrder
    answers?: SortOrder
    answer_count?: SortOrder
    answer_right?: SortOrder
    test_id?: SortOrder
    _count?: AnswersCountOrderByAggregateInput
    _avg?: AnswersAvgOrderByAggregateInput
    _max?: AnswersMaxOrderByAggregateInput
    _min?: AnswersMinOrderByAggregateInput
    _sum?: AnswersSumOrderByAggregateInput
  }

  export type AnswersScalarWhereWithAggregatesInput = {
    AND?: AnswersScalarWhereWithAggregatesInput | AnswersScalarWhereWithAggregatesInput[]
    OR?: AnswersScalarWhereWithAggregatesInput[]
    NOT?: AnswersScalarWhereWithAggregatesInput | AnswersScalarWhereWithAggregatesInput[]
    answer_id?: IntWithAggregatesFilter<"Answers"> | number
    question?: StringWithAggregatesFilter<"Answers"> | string
    answers?: StringWithAggregatesFilter<"Answers"> | string
    answer_count?: IntWithAggregatesFilter<"Answers"> | number
    answer_right?: IntWithAggregatesFilter<"Answers"> | number
    test_id?: IntWithAggregatesFilter<"Answers"> | number
  }

  export type CoursesWhereInput = {
    AND?: CoursesWhereInput | CoursesWhereInput[]
    OR?: CoursesWhereInput[]
    NOT?: CoursesWhereInput | CoursesWhereInput[]
    course_id?: IntFilter<"Courses"> | number
    course_name?: StringFilter<"Courses"> | string
    course_cost?: IntFilter<"Courses"> | number
    course_description?: StringNullableFilter<"Courses"> | string | null
    course_descipline?: StringFilter<"Courses"> | string
    Desciplines?: XOR<DesciplinesRelationFilter, DesciplinesWhereInput>
    Materials?: MaterialsListRelationFilter
    StudentToCourse?: StudentToCourseListRelationFilter
    TeacherToCourse?: TeacherToCourseListRelationFilter
    Tests?: TestsListRelationFilter
  }

  export type CoursesOrderByWithRelationInput = {
    course_id?: SortOrder
    course_name?: SortOrder
    course_cost?: SortOrder
    course_description?: SortOrderInput | SortOrder
    course_descipline?: SortOrder
    Desciplines?: DesciplinesOrderByWithRelationInput
    Materials?: MaterialsOrderByRelationAggregateInput
    StudentToCourse?: StudentToCourseOrderByRelationAggregateInput
    TeacherToCourse?: TeacherToCourseOrderByRelationAggregateInput
    Tests?: TestsOrderByRelationAggregateInput
  }

  export type CoursesWhereUniqueInput = Prisma.AtLeast<{
    course_id?: number
    AND?: CoursesWhereInput | CoursesWhereInput[]
    OR?: CoursesWhereInput[]
    NOT?: CoursesWhereInput | CoursesWhereInput[]
    course_name?: StringFilter<"Courses"> | string
    course_cost?: IntFilter<"Courses"> | number
    course_description?: StringNullableFilter<"Courses"> | string | null
    course_descipline?: StringFilter<"Courses"> | string
    Desciplines?: XOR<DesciplinesRelationFilter, DesciplinesWhereInput>
    Materials?: MaterialsListRelationFilter
    StudentToCourse?: StudentToCourseListRelationFilter
    TeacherToCourse?: TeacherToCourseListRelationFilter
    Tests?: TestsListRelationFilter
  }, "course_id">

  export type CoursesOrderByWithAggregationInput = {
    course_id?: SortOrder
    course_name?: SortOrder
    course_cost?: SortOrder
    course_description?: SortOrderInput | SortOrder
    course_descipline?: SortOrder
    _count?: CoursesCountOrderByAggregateInput
    _avg?: CoursesAvgOrderByAggregateInput
    _max?: CoursesMaxOrderByAggregateInput
    _min?: CoursesMinOrderByAggregateInput
    _sum?: CoursesSumOrderByAggregateInput
  }

  export type CoursesScalarWhereWithAggregatesInput = {
    AND?: CoursesScalarWhereWithAggregatesInput | CoursesScalarWhereWithAggregatesInput[]
    OR?: CoursesScalarWhereWithAggregatesInput[]
    NOT?: CoursesScalarWhereWithAggregatesInput | CoursesScalarWhereWithAggregatesInput[]
    course_id?: IntWithAggregatesFilter<"Courses"> | number
    course_name?: StringWithAggregatesFilter<"Courses"> | string
    course_cost?: IntWithAggregatesFilter<"Courses"> | number
    course_description?: StringNullableWithAggregatesFilter<"Courses"> | string | null
    course_descipline?: StringWithAggregatesFilter<"Courses"> | string
  }

  export type DesciplinesWhereInput = {
    AND?: DesciplinesWhereInput | DesciplinesWhereInput[]
    OR?: DesciplinesWhereInput[]
    NOT?: DesciplinesWhereInput | DesciplinesWhereInput[]
    descipline_name?: StringFilter<"Desciplines"> | string
    Courses?: CoursesListRelationFilter
    Teachers?: TeachersListRelationFilter
  }

  export type DesciplinesOrderByWithRelationInput = {
    descipline_name?: SortOrder
    Courses?: CoursesOrderByRelationAggregateInput
    Teachers?: TeachersOrderByRelationAggregateInput
  }

  export type DesciplinesWhereUniqueInput = Prisma.AtLeast<{
    descipline_name?: string
    AND?: DesciplinesWhereInput | DesciplinesWhereInput[]
    OR?: DesciplinesWhereInput[]
    NOT?: DesciplinesWhereInput | DesciplinesWhereInput[]
    Courses?: CoursesListRelationFilter
    Teachers?: TeachersListRelationFilter
  }, "descipline_name">

  export type DesciplinesOrderByWithAggregationInput = {
    descipline_name?: SortOrder
    _count?: DesciplinesCountOrderByAggregateInput
    _max?: DesciplinesMaxOrderByAggregateInput
    _min?: DesciplinesMinOrderByAggregateInput
  }

  export type DesciplinesScalarWhereWithAggregatesInput = {
    AND?: DesciplinesScalarWhereWithAggregatesInput | DesciplinesScalarWhereWithAggregatesInput[]
    OR?: DesciplinesScalarWhereWithAggregatesInput[]
    NOT?: DesciplinesScalarWhereWithAggregatesInput | DesciplinesScalarWhereWithAggregatesInput[]
    descipline_name?: StringWithAggregatesFilter<"Desciplines"> | string
  }

  export type MaterialsWhereInput = {
    AND?: MaterialsWhereInput | MaterialsWhereInput[]
    OR?: MaterialsWhereInput[]
    NOT?: MaterialsWhereInput | MaterialsWhereInput[]
    material_id?: IntFilter<"Materials"> | number
    material_name?: StringFilter<"Materials"> | string
    course_id?: IntFilter<"Materials"> | number
    material_ingo?: StringNullableFilter<"Materials"> | string | null
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
  }

  export type MaterialsOrderByWithRelationInput = {
    material_id?: SortOrder
    material_name?: SortOrder
    course_id?: SortOrder
    material_ingo?: SortOrderInput | SortOrder
    Courses?: CoursesOrderByWithRelationInput
  }

  export type MaterialsWhereUniqueInput = Prisma.AtLeast<{
    material_id?: number
    AND?: MaterialsWhereInput | MaterialsWhereInput[]
    OR?: MaterialsWhereInput[]
    NOT?: MaterialsWhereInput | MaterialsWhereInput[]
    material_name?: StringFilter<"Materials"> | string
    course_id?: IntFilter<"Materials"> | number
    material_ingo?: StringNullableFilter<"Materials"> | string | null
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
  }, "material_id">

  export type MaterialsOrderByWithAggregationInput = {
    material_id?: SortOrder
    material_name?: SortOrder
    course_id?: SortOrder
    material_ingo?: SortOrderInput | SortOrder
    _count?: MaterialsCountOrderByAggregateInput
    _avg?: MaterialsAvgOrderByAggregateInput
    _max?: MaterialsMaxOrderByAggregateInput
    _min?: MaterialsMinOrderByAggregateInput
    _sum?: MaterialsSumOrderByAggregateInput
  }

  export type MaterialsScalarWhereWithAggregatesInput = {
    AND?: MaterialsScalarWhereWithAggregatesInput | MaterialsScalarWhereWithAggregatesInput[]
    OR?: MaterialsScalarWhereWithAggregatesInput[]
    NOT?: MaterialsScalarWhereWithAggregatesInput | MaterialsScalarWhereWithAggregatesInput[]
    material_id?: IntWithAggregatesFilter<"Materials"> | number
    material_name?: StringWithAggregatesFilter<"Materials"> | string
    course_id?: IntWithAggregatesFilter<"Materials"> | number
    material_ingo?: StringNullableWithAggregatesFilter<"Materials"> | string | null
  }

  export type StudentsWhereInput = {
    AND?: StudentsWhereInput | StudentsWhereInput[]
    OR?: StudentsWhereInput[]
    NOT?: StudentsWhereInput | StudentsWhereInput[]
    user_ident?: IntFilter<"Students"> | number
    fio?: StringFilter<"Students"> | string
    balance?: IntNullableFilter<"Students"> | number | null
    email?: StringFilter<"Students"> | string
    user_password?: StringFilter<"Students"> | string
    StudentToCourse?: StudentToCourseListRelationFilter
    TestStatus?: TestStatusListRelationFilter
  }

  export type StudentsOrderByWithRelationInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    balance?: SortOrderInput | SortOrder
    email?: SortOrder
    user_password?: SortOrder
    StudentToCourse?: StudentToCourseOrderByRelationAggregateInput
    TestStatus?: TestStatusOrderByRelationAggregateInput
  }

  export type StudentsWhereUniqueInput = Prisma.AtLeast<{
    user_ident?: number
    fio?: string
    AND?: StudentsWhereInput | StudentsWhereInput[]
    OR?: StudentsWhereInput[]
    NOT?: StudentsWhereInput | StudentsWhereInput[]
    balance?: IntNullableFilter<"Students"> | number | null
    email?: StringFilter<"Students"> | string
    user_password?: StringFilter<"Students"> | string
    StudentToCourse?: StudentToCourseListRelationFilter
    TestStatus?: TestStatusListRelationFilter
  }, "user_ident" | "fio">

  export type StudentsOrderByWithAggregationInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    balance?: SortOrderInput | SortOrder
    email?: SortOrder
    user_password?: SortOrder
    _count?: StudentsCountOrderByAggregateInput
    _avg?: StudentsAvgOrderByAggregateInput
    _max?: StudentsMaxOrderByAggregateInput
    _min?: StudentsMinOrderByAggregateInput
    _sum?: StudentsSumOrderByAggregateInput
  }

  export type StudentsScalarWhereWithAggregatesInput = {
    AND?: StudentsScalarWhereWithAggregatesInput | StudentsScalarWhereWithAggregatesInput[]
    OR?: StudentsScalarWhereWithAggregatesInput[]
    NOT?: StudentsScalarWhereWithAggregatesInput | StudentsScalarWhereWithAggregatesInput[]
    user_ident?: IntWithAggregatesFilter<"Students"> | number
    fio?: StringWithAggregatesFilter<"Students"> | string
    balance?: IntNullableWithAggregatesFilter<"Students"> | number | null
    email?: StringWithAggregatesFilter<"Students"> | string
    user_password?: StringWithAggregatesFilter<"Students"> | string
  }

  export type StudentToCourseWhereInput = {
    AND?: StudentToCourseWhereInput | StudentToCourseWhereInput[]
    OR?: StudentToCourseWhereInput[]
    NOT?: StudentToCourseWhereInput | StudentToCourseWhereInput[]
    STC_id?: IntFilter<"StudentToCourse"> | number
    course_id?: IntFilter<"StudentToCourse"> | number
    student_id?: IntFilter<"StudentToCourse"> | number
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Students?: XOR<StudentsRelationFilter, StudentsWhereInput>
  }

  export type StudentToCourseOrderByWithRelationInput = {
    STC_id?: SortOrder
    course_id?: SortOrder
    student_id?: SortOrder
    Courses?: CoursesOrderByWithRelationInput
    Students?: StudentsOrderByWithRelationInput
  }

  export type StudentToCourseWhereUniqueInput = Prisma.AtLeast<{
    STC_id?: number
    AND?: StudentToCourseWhereInput | StudentToCourseWhereInput[]
    OR?: StudentToCourseWhereInput[]
    NOT?: StudentToCourseWhereInput | StudentToCourseWhereInput[]
    course_id?: IntFilter<"StudentToCourse"> | number
    student_id?: IntFilter<"StudentToCourse"> | number
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Students?: XOR<StudentsRelationFilter, StudentsWhereInput>
  }, "STC_id">

  export type StudentToCourseOrderByWithAggregationInput = {
    STC_id?: SortOrder
    course_id?: SortOrder
    student_id?: SortOrder
    _count?: StudentToCourseCountOrderByAggregateInput
    _avg?: StudentToCourseAvgOrderByAggregateInput
    _max?: StudentToCourseMaxOrderByAggregateInput
    _min?: StudentToCourseMinOrderByAggregateInput
    _sum?: StudentToCourseSumOrderByAggregateInput
  }

  export type StudentToCourseScalarWhereWithAggregatesInput = {
    AND?: StudentToCourseScalarWhereWithAggregatesInput | StudentToCourseScalarWhereWithAggregatesInput[]
    OR?: StudentToCourseScalarWhereWithAggregatesInput[]
    NOT?: StudentToCourseScalarWhereWithAggregatesInput | StudentToCourseScalarWhereWithAggregatesInput[]
    STC_id?: IntWithAggregatesFilter<"StudentToCourse"> | number
    course_id?: IntWithAggregatesFilter<"StudentToCourse"> | number
    student_id?: IntWithAggregatesFilter<"StudentToCourse"> | number
  }

  export type TeachersWhereInput = {
    AND?: TeachersWhereInput | TeachersWhereInput[]
    OR?: TeachersWhereInput[]
    NOT?: TeachersWhereInput | TeachersWhereInput[]
    user_ident?: IntFilter<"Teachers"> | number
    fio?: StringFilter<"Teachers"> | string
    email?: StringFilter<"Teachers"> | string
    user_password?: StringFilter<"Teachers"> | string
    descipline?: StringFilter<"Teachers"> | string
    Desciplines?: XOR<DesciplinesRelationFilter, DesciplinesWhereInput>
    TeacherToCourse?: TeacherToCourseListRelationFilter
  }

  export type TeachersOrderByWithRelationInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    email?: SortOrder
    user_password?: SortOrder
    descipline?: SortOrder
    Desciplines?: DesciplinesOrderByWithRelationInput
    TeacherToCourse?: TeacherToCourseOrderByRelationAggregateInput
  }

  export type TeachersWhereUniqueInput = Prisma.AtLeast<{
    user_ident?: number
    fio?: string
    AND?: TeachersWhereInput | TeachersWhereInput[]
    OR?: TeachersWhereInput[]
    NOT?: TeachersWhereInput | TeachersWhereInput[]
    email?: StringFilter<"Teachers"> | string
    user_password?: StringFilter<"Teachers"> | string
    descipline?: StringFilter<"Teachers"> | string
    Desciplines?: XOR<DesciplinesRelationFilter, DesciplinesWhereInput>
    TeacherToCourse?: TeacherToCourseListRelationFilter
  }, "user_ident" | "fio">

  export type TeachersOrderByWithAggregationInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    email?: SortOrder
    user_password?: SortOrder
    descipline?: SortOrder
    _count?: TeachersCountOrderByAggregateInput
    _avg?: TeachersAvgOrderByAggregateInput
    _max?: TeachersMaxOrderByAggregateInput
    _min?: TeachersMinOrderByAggregateInput
    _sum?: TeachersSumOrderByAggregateInput
  }

  export type TeachersScalarWhereWithAggregatesInput = {
    AND?: TeachersScalarWhereWithAggregatesInput | TeachersScalarWhereWithAggregatesInput[]
    OR?: TeachersScalarWhereWithAggregatesInput[]
    NOT?: TeachersScalarWhereWithAggregatesInput | TeachersScalarWhereWithAggregatesInput[]
    user_ident?: IntWithAggregatesFilter<"Teachers"> | number
    fio?: StringWithAggregatesFilter<"Teachers"> | string
    email?: StringWithAggregatesFilter<"Teachers"> | string
    user_password?: StringWithAggregatesFilter<"Teachers"> | string
    descipline?: StringWithAggregatesFilter<"Teachers"> | string
  }

  export type TeacherToCourseWhereInput = {
    AND?: TeacherToCourseWhereInput | TeacherToCourseWhereInput[]
    OR?: TeacherToCourseWhereInput[]
    NOT?: TeacherToCourseWhereInput | TeacherToCourseWhereInput[]
    TTC_id?: IntFilter<"TeacherToCourse"> | number
    teacher_id?: IntFilter<"TeacherToCourse"> | number
    course_id?: IntFilter<"TeacherToCourse"> | number
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Teachers?: XOR<TeachersRelationFilter, TeachersWhereInput>
  }

  export type TeacherToCourseOrderByWithRelationInput = {
    TTC_id?: SortOrder
    teacher_id?: SortOrder
    course_id?: SortOrder
    Courses?: CoursesOrderByWithRelationInput
    Teachers?: TeachersOrderByWithRelationInput
  }

  export type TeacherToCourseWhereUniqueInput = Prisma.AtLeast<{
    TTC_id?: number
    AND?: TeacherToCourseWhereInput | TeacherToCourseWhereInput[]
    OR?: TeacherToCourseWhereInput[]
    NOT?: TeacherToCourseWhereInput | TeacherToCourseWhereInput[]
    teacher_id?: IntFilter<"TeacherToCourse"> | number
    course_id?: IntFilter<"TeacherToCourse"> | number
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    Teachers?: XOR<TeachersRelationFilter, TeachersWhereInput>
  }, "TTC_id">

  export type TeacherToCourseOrderByWithAggregationInput = {
    TTC_id?: SortOrder
    teacher_id?: SortOrder
    course_id?: SortOrder
    _count?: TeacherToCourseCountOrderByAggregateInput
    _avg?: TeacherToCourseAvgOrderByAggregateInput
    _max?: TeacherToCourseMaxOrderByAggregateInput
    _min?: TeacherToCourseMinOrderByAggregateInput
    _sum?: TeacherToCourseSumOrderByAggregateInput
  }

  export type TeacherToCourseScalarWhereWithAggregatesInput = {
    AND?: TeacherToCourseScalarWhereWithAggregatesInput | TeacherToCourseScalarWhereWithAggregatesInput[]
    OR?: TeacherToCourseScalarWhereWithAggregatesInput[]
    NOT?: TeacherToCourseScalarWhereWithAggregatesInput | TeacherToCourseScalarWhereWithAggregatesInput[]
    TTC_id?: IntWithAggregatesFilter<"TeacherToCourse"> | number
    teacher_id?: IntWithAggregatesFilter<"TeacherToCourse"> | number
    course_id?: IntWithAggregatesFilter<"TeacherToCourse"> | number
  }

  export type TestsWhereInput = {
    AND?: TestsWhereInput | TestsWhereInput[]
    OR?: TestsWhereInput[]
    NOT?: TestsWhereInput | TestsWhereInput[]
    test_id?: IntFilter<"Tests"> | number
    test_name?: StringFilter<"Tests"> | string
    test_desc?: StringFilter<"Tests"> | string
    course_id?: IntFilter<"Tests"> | number
    Answers?: AnswersListRelationFilter
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    TestStatus?: TestStatusListRelationFilter
  }

  export type TestsOrderByWithRelationInput = {
    test_id?: SortOrder
    test_name?: SortOrder
    test_desc?: SortOrder
    course_id?: SortOrder
    Answers?: AnswersOrderByRelationAggregateInput
    Courses?: CoursesOrderByWithRelationInput
    TestStatus?: TestStatusOrderByRelationAggregateInput
  }

  export type TestsWhereUniqueInput = Prisma.AtLeast<{
    test_id?: number
    AND?: TestsWhereInput | TestsWhereInput[]
    OR?: TestsWhereInput[]
    NOT?: TestsWhereInput | TestsWhereInput[]
    test_name?: StringFilter<"Tests"> | string
    test_desc?: StringFilter<"Tests"> | string
    course_id?: IntFilter<"Tests"> | number
    Answers?: AnswersListRelationFilter
    Courses?: XOR<CoursesRelationFilter, CoursesWhereInput>
    TestStatus?: TestStatusListRelationFilter
  }, "test_id">

  export type TestsOrderByWithAggregationInput = {
    test_id?: SortOrder
    test_name?: SortOrder
    test_desc?: SortOrder
    course_id?: SortOrder
    _count?: TestsCountOrderByAggregateInput
    _avg?: TestsAvgOrderByAggregateInput
    _max?: TestsMaxOrderByAggregateInput
    _min?: TestsMinOrderByAggregateInput
    _sum?: TestsSumOrderByAggregateInput
  }

  export type TestsScalarWhereWithAggregatesInput = {
    AND?: TestsScalarWhereWithAggregatesInput | TestsScalarWhereWithAggregatesInput[]
    OR?: TestsScalarWhereWithAggregatesInput[]
    NOT?: TestsScalarWhereWithAggregatesInput | TestsScalarWhereWithAggregatesInput[]
    test_id?: IntWithAggregatesFilter<"Tests"> | number
    test_name?: StringWithAggregatesFilter<"Tests"> | string
    test_desc?: StringWithAggregatesFilter<"Tests"> | string
    course_id?: IntWithAggregatesFilter<"Tests"> | number
  }

  export type TestStatusWhereInput = {
    AND?: TestStatusWhereInput | TestStatusWhereInput[]
    OR?: TestStatusWhereInput[]
    NOT?: TestStatusWhereInput | TestStatusWhereInput[]
    status_id?: IntFilter<"TestStatus"> | number
    test_id?: IntFilter<"TestStatus"> | number
    student_id?: IntFilter<"TestStatus"> | number
    Students?: XOR<StudentsRelationFilter, StudentsWhereInput>
    Tests?: XOR<TestsRelationFilter, TestsWhereInput>
  }

  export type TestStatusOrderByWithRelationInput = {
    status_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
    Students?: StudentsOrderByWithRelationInput
    Tests?: TestsOrderByWithRelationInput
  }

  export type TestStatusWhereUniqueInput = Prisma.AtLeast<{
    status_id?: number
    AND?: TestStatusWhereInput | TestStatusWhereInput[]
    OR?: TestStatusWhereInput[]
    NOT?: TestStatusWhereInput | TestStatusWhereInput[]
    test_id?: IntFilter<"TestStatus"> | number
    student_id?: IntFilter<"TestStatus"> | number
    Students?: XOR<StudentsRelationFilter, StudentsWhereInput>
    Tests?: XOR<TestsRelationFilter, TestsWhereInput>
  }, "status_id">

  export type TestStatusOrderByWithAggregationInput = {
    status_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
    _count?: TestStatusCountOrderByAggregateInput
    _avg?: TestStatusAvgOrderByAggregateInput
    _max?: TestStatusMaxOrderByAggregateInput
    _min?: TestStatusMinOrderByAggregateInput
    _sum?: TestStatusSumOrderByAggregateInput
  }

  export type TestStatusScalarWhereWithAggregatesInput = {
    AND?: TestStatusScalarWhereWithAggregatesInput | TestStatusScalarWhereWithAggregatesInput[]
    OR?: TestStatusScalarWhereWithAggregatesInput[]
    NOT?: TestStatusScalarWhereWithAggregatesInput | TestStatusScalarWhereWithAggregatesInput[]
    status_id?: IntWithAggregatesFilter<"TestStatus"> | number
    test_id?: IntWithAggregatesFilter<"TestStatus"> | number
    student_id?: IntWithAggregatesFilter<"TestStatus"> | number
  }

  export type AnswersCreateInput = {
    answer_id: number
    question: string
    answers: string
    answer_count: number
    answer_right: number
    Tests: TestsCreateNestedOneWithoutAnswersInput
  }

  export type AnswersUncheckedCreateInput = {
    answer_id: number
    question: string
    answers: string
    answer_count: number
    answer_right: number
    test_id: number
  }

  export type AnswersUpdateInput = {
    answer_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answers?: StringFieldUpdateOperationsInput | string
    answer_count?: IntFieldUpdateOperationsInput | number
    answer_right?: IntFieldUpdateOperationsInput | number
    Tests?: TestsUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type AnswersUncheckedUpdateInput = {
    answer_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answers?: StringFieldUpdateOperationsInput | string
    answer_count?: IntFieldUpdateOperationsInput | number
    answer_right?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
  }

  export type AnswersCreateManyInput = {
    answer_id: number
    question: string
    answers: string
    answer_count: number
    answer_right: number
    test_id: number
  }

  export type AnswersUpdateManyMutationInput = {
    answer_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answers?: StringFieldUpdateOperationsInput | string
    answer_count?: IntFieldUpdateOperationsInput | number
    answer_right?: IntFieldUpdateOperationsInput | number
  }

  export type AnswersUncheckedUpdateManyInput = {
    answer_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answers?: StringFieldUpdateOperationsInput | string
    answer_count?: IntFieldUpdateOperationsInput | number
    answer_right?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
  }

  export type CoursesCreateInput = {
    course_name: string
    course_cost: number
    course_description?: string | null
    Desciplines: DesciplinesCreateNestedOneWithoutCoursesInput
    Materials?: MaterialsCreateNestedManyWithoutCoursesInput
    StudentToCourse?: StudentToCourseCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseCreateNestedManyWithoutCoursesInput
    Tests?: TestsCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateInput = {
    course_id?: number
    course_name: string
    course_cost: number
    course_description?: string | null
    course_descipline: string
    Materials?: MaterialsUncheckedCreateNestedManyWithoutCoursesInput
    StudentToCourse?: StudentToCourseUncheckedCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseUncheckedCreateNestedManyWithoutCoursesInput
    Tests?: TestsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUpdateInput = {
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    Desciplines?: DesciplinesUpdateOneRequiredWithoutCoursesNestedInput
    Materials?: MaterialsUpdateManyWithoutCoursesNestedInput
    StudentToCourse?: StudentToCourseUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    course_descipline?: StringFieldUpdateOperationsInput | string
    Materials?: MaterialsUncheckedUpdateManyWithoutCoursesNestedInput
    StudentToCourse?: StudentToCourseUncheckedUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUncheckedUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesCreateManyInput = {
    course_name: string
    course_cost: number
    course_description?: string | null
    course_descipline: string
  }

  export type CoursesUpdateManyMutationInput = {
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CoursesUncheckedUpdateManyInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    course_descipline?: StringFieldUpdateOperationsInput | string
  }

  export type DesciplinesCreateInput = {
    descipline_name: string
    Courses?: CoursesCreateNestedManyWithoutDesciplinesInput
    Teachers?: TeachersCreateNestedManyWithoutDesciplinesInput
  }

  export type DesciplinesUncheckedCreateInput = {
    descipline_name: string
    Courses?: CoursesUncheckedCreateNestedManyWithoutDesciplinesInput
    Teachers?: TeachersUncheckedCreateNestedManyWithoutDesciplinesInput
  }

  export type DesciplinesUpdateInput = {
    descipline_name?: StringFieldUpdateOperationsInput | string
    Courses?: CoursesUpdateManyWithoutDesciplinesNestedInput
    Teachers?: TeachersUpdateManyWithoutDesciplinesNestedInput
  }

  export type DesciplinesUncheckedUpdateInput = {
    descipline_name?: StringFieldUpdateOperationsInput | string
    Courses?: CoursesUncheckedUpdateManyWithoutDesciplinesNestedInput
    Teachers?: TeachersUncheckedUpdateManyWithoutDesciplinesNestedInput
  }

  export type DesciplinesCreateManyInput = {
    descipline_name: string
  }

  export type DesciplinesUpdateManyMutationInput = {
    descipline_name?: StringFieldUpdateOperationsInput | string
  }

  export type DesciplinesUncheckedUpdateManyInput = {
    descipline_name?: StringFieldUpdateOperationsInput | string
  }

  export type MaterialsCreateInput = {
    material_name: string
    material_ingo?: string | null
    Courses: CoursesCreateNestedOneWithoutMaterialsInput
  }

  export type MaterialsUncheckedCreateInput = {
    material_id?: number
    material_name: string
    course_id: number
    material_ingo?: string | null
  }

  export type MaterialsUpdateInput = {
    material_name?: StringFieldUpdateOperationsInput | string
    material_ingo?: NullableStringFieldUpdateOperationsInput | string | null
    Courses?: CoursesUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type MaterialsUncheckedUpdateInput = {
    material_id?: IntFieldUpdateOperationsInput | number
    material_name?: StringFieldUpdateOperationsInput | string
    course_id?: IntFieldUpdateOperationsInput | number
    material_ingo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialsCreateManyInput = {
    material_name: string
    course_id: number
    material_ingo?: string | null
  }

  export type MaterialsUpdateManyMutationInput = {
    material_name?: StringFieldUpdateOperationsInput | string
    material_ingo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialsUncheckedUpdateManyInput = {
    material_id?: IntFieldUpdateOperationsInput | number
    material_name?: StringFieldUpdateOperationsInput | string
    course_id?: IntFieldUpdateOperationsInput | number
    material_ingo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentsCreateInput = {
    fio: string
    balance?: number | null
    email: string
    user_password: string
    StudentToCourse?: StudentToCourseCreateNestedManyWithoutStudentsInput
    TestStatus?: TestStatusCreateNestedManyWithoutStudentsInput
  }

  export type StudentsUncheckedCreateInput = {
    user_ident?: number
    fio: string
    balance?: number | null
    email: string
    user_password: string
    StudentToCourse?: StudentToCourseUncheckedCreateNestedManyWithoutStudentsInput
    TestStatus?: TestStatusUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type StudentsUpdateInput = {
    fio?: StringFieldUpdateOperationsInput | string
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    StudentToCourse?: StudentToCourseUpdateManyWithoutStudentsNestedInput
    TestStatus?: TestStatusUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsUncheckedUpdateInput = {
    user_ident?: IntFieldUpdateOperationsInput | number
    fio?: StringFieldUpdateOperationsInput | string
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    StudentToCourse?: StudentToCourseUncheckedUpdateManyWithoutStudentsNestedInput
    TestStatus?: TestStatusUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsCreateManyInput = {
    fio: string
    balance?: number | null
    email: string
    user_password: string
  }

  export type StudentsUpdateManyMutationInput = {
    fio?: StringFieldUpdateOperationsInput | string
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
  }

  export type StudentsUncheckedUpdateManyInput = {
    user_ident?: IntFieldUpdateOperationsInput | number
    fio?: StringFieldUpdateOperationsInput | string
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
  }

  export type StudentToCourseCreateInput = {
    Courses: CoursesCreateNestedOneWithoutStudentToCourseInput
    Students: StudentsCreateNestedOneWithoutStudentToCourseInput
  }

  export type StudentToCourseUncheckedCreateInput = {
    STC_id?: number
    course_id: number
    student_id: number
  }

  export type StudentToCourseUpdateInput = {
    Courses?: CoursesUpdateOneRequiredWithoutStudentToCourseNestedInput
    Students?: StudentsUpdateOneRequiredWithoutStudentToCourseNestedInput
  }

  export type StudentToCourseUncheckedUpdateInput = {
    STC_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
  }

  export type StudentToCourseCreateManyInput = {
    course_id: number
    student_id: number
  }

  export type StudentToCourseUpdateManyMutationInput = {

  }

  export type StudentToCourseUncheckedUpdateManyInput = {
    STC_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
  }

  export type TeachersCreateInput = {
    fio: string
    email: string
    user_password: string
    Desciplines: DesciplinesCreateNestedOneWithoutTeachersInput
    TeacherToCourse?: TeacherToCourseCreateNestedManyWithoutTeachersInput
  }

  export type TeachersUncheckedCreateInput = {
    user_ident?: number
    fio: string
    email: string
    user_password: string
    descipline: string
    TeacherToCourse?: TeacherToCourseUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type TeachersUpdateInput = {
    fio?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    Desciplines?: DesciplinesUpdateOneRequiredWithoutTeachersNestedInput
    TeacherToCourse?: TeacherToCourseUpdateManyWithoutTeachersNestedInput
  }

  export type TeachersUncheckedUpdateInput = {
    user_ident?: IntFieldUpdateOperationsInput | number
    fio?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    descipline?: StringFieldUpdateOperationsInput | string
    TeacherToCourse?: TeacherToCourseUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type TeachersCreateManyInput = {
    fio: string
    email: string
    user_password: string
    descipline: string
  }

  export type TeachersUpdateManyMutationInput = {
    fio?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
  }

  export type TeachersUncheckedUpdateManyInput = {
    user_ident?: IntFieldUpdateOperationsInput | number
    fio?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    descipline?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherToCourseCreateInput = {
    TTC_id: number
    Courses: CoursesCreateNestedOneWithoutTeacherToCourseInput
    Teachers: TeachersCreateNestedOneWithoutTeacherToCourseInput
  }

  export type TeacherToCourseUncheckedCreateInput = {
    TTC_id: number
    teacher_id: number
    course_id: number
  }

  export type TeacherToCourseUpdateInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
    Courses?: CoursesUpdateOneRequiredWithoutTeacherToCourseNestedInput
    Teachers?: TeachersUpdateOneRequiredWithoutTeacherToCourseNestedInput
  }

  export type TeacherToCourseUncheckedUpdateInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherToCourseCreateManyInput = {
    TTC_id: number
    teacher_id: number
    course_id: number
  }

  export type TeacherToCourseUpdateManyMutationInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherToCourseUncheckedUpdateManyInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type TestsCreateInput = {
    test_name: string
    test_desc: string
    Answers?: AnswersCreateNestedManyWithoutTestsInput
    Courses: CoursesCreateNestedOneWithoutTestsInput
    TestStatus?: TestStatusCreateNestedManyWithoutTestsInput
  }

  export type TestsUncheckedCreateInput = {
    test_id?: number
    test_name: string
    test_desc: string
    course_id: number
    Answers?: AnswersUncheckedCreateNestedManyWithoutTestsInput
    TestStatus?: TestStatusUncheckedCreateNestedManyWithoutTestsInput
  }

  export type TestsUpdateInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
    Answers?: AnswersUpdateManyWithoutTestsNestedInput
    Courses?: CoursesUpdateOneRequiredWithoutTestsNestedInput
    TestStatus?: TestStatusUpdateManyWithoutTestsNestedInput
  }

  export type TestsUncheckedUpdateInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
    course_id?: IntFieldUpdateOperationsInput | number
    Answers?: AnswersUncheckedUpdateManyWithoutTestsNestedInput
    TestStatus?: TestStatusUncheckedUpdateManyWithoutTestsNestedInput
  }

  export type TestsCreateManyInput = {
    test_name: string
    test_desc: string
    course_id: number
  }

  export type TestsUpdateManyMutationInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
  }

  export type TestsUncheckedUpdateManyInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type TestStatusCreateInput = {
    Students: StudentsCreateNestedOneWithoutTestStatusInput
    Tests: TestsCreateNestedOneWithoutTestStatusInput
  }

  export type TestStatusUncheckedCreateInput = {
    status_id?: number
    test_id: number
    student_id: number
  }

  export type TestStatusUpdateInput = {
    Students?: StudentsUpdateOneRequiredWithoutTestStatusNestedInput
    Tests?: TestsUpdateOneRequiredWithoutTestStatusNestedInput
  }

  export type TestStatusUncheckedUpdateInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
  }

  export type TestStatusCreateManyInput = {
    test_id: number
    student_id: number
  }

  export type TestStatusUpdateManyMutationInput = {

  }

  export type TestStatusUncheckedUpdateManyInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type TestsRelationFilter = {
    is?: TestsWhereInput
    isNot?: TestsWhereInput
  }

  export type AnswersCountOrderByAggregateInput = {
    answer_id?: SortOrder
    question?: SortOrder
    answers?: SortOrder
    answer_count?: SortOrder
    answer_right?: SortOrder
    test_id?: SortOrder
  }

  export type AnswersAvgOrderByAggregateInput = {
    answer_id?: SortOrder
    answer_count?: SortOrder
    answer_right?: SortOrder
    test_id?: SortOrder
  }

  export type AnswersMaxOrderByAggregateInput = {
    answer_id?: SortOrder
    question?: SortOrder
    answers?: SortOrder
    answer_count?: SortOrder
    answer_right?: SortOrder
    test_id?: SortOrder
  }

  export type AnswersMinOrderByAggregateInput = {
    answer_id?: SortOrder
    question?: SortOrder
    answers?: SortOrder
    answer_count?: SortOrder
    answer_right?: SortOrder
    test_id?: SortOrder
  }

  export type AnswersSumOrderByAggregateInput = {
    answer_id?: SortOrder
    answer_count?: SortOrder
    answer_right?: SortOrder
    test_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DesciplinesRelationFilter = {
    is?: DesciplinesWhereInput
    isNot?: DesciplinesWhereInput
  }

  export type MaterialsListRelationFilter = {
    every?: MaterialsWhereInput
    some?: MaterialsWhereInput
    none?: MaterialsWhereInput
  }

  export type StudentToCourseListRelationFilter = {
    every?: StudentToCourseWhereInput
    some?: StudentToCourseWhereInput
    none?: StudentToCourseWhereInput
  }

  export type TeacherToCourseListRelationFilter = {
    every?: TeacherToCourseWhereInput
    some?: TeacherToCourseWhereInput
    none?: TeacherToCourseWhereInput
  }

  export type TestsListRelationFilter = {
    every?: TestsWhereInput
    some?: TestsWhereInput
    none?: TestsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MaterialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentToCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherToCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoursesCountOrderByAggregateInput = {
    course_id?: SortOrder
    course_name?: SortOrder
    course_cost?: SortOrder
    course_description?: SortOrder
    course_descipline?: SortOrder
  }

  export type CoursesAvgOrderByAggregateInput = {
    course_id?: SortOrder
    course_cost?: SortOrder
  }

  export type CoursesMaxOrderByAggregateInput = {
    course_id?: SortOrder
    course_name?: SortOrder
    course_cost?: SortOrder
    course_description?: SortOrder
    course_descipline?: SortOrder
  }

  export type CoursesMinOrderByAggregateInput = {
    course_id?: SortOrder
    course_name?: SortOrder
    course_cost?: SortOrder
    course_description?: SortOrder
    course_descipline?: SortOrder
  }

  export type CoursesSumOrderByAggregateInput = {
    course_id?: SortOrder
    course_cost?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CoursesListRelationFilter = {
    every?: CoursesWhereInput
    some?: CoursesWhereInput
    none?: CoursesWhereInput
  }

  export type TeachersListRelationFilter = {
    every?: TeachersWhereInput
    some?: TeachersWhereInput
    none?: TeachersWhereInput
  }

  export type CoursesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeachersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DesciplinesCountOrderByAggregateInput = {
    descipline_name?: SortOrder
  }

  export type DesciplinesMaxOrderByAggregateInput = {
    descipline_name?: SortOrder
  }

  export type DesciplinesMinOrderByAggregateInput = {
    descipline_name?: SortOrder
  }

  export type CoursesRelationFilter = {
    is?: CoursesWhereInput
    isNot?: CoursesWhereInput
  }

  export type MaterialsCountOrderByAggregateInput = {
    material_id?: SortOrder
    material_name?: SortOrder
    course_id?: SortOrder
    material_ingo?: SortOrder
  }

  export type MaterialsAvgOrderByAggregateInput = {
    material_id?: SortOrder
    course_id?: SortOrder
  }

  export type MaterialsMaxOrderByAggregateInput = {
    material_id?: SortOrder
    material_name?: SortOrder
    course_id?: SortOrder
    material_ingo?: SortOrder
  }

  export type MaterialsMinOrderByAggregateInput = {
    material_id?: SortOrder
    material_name?: SortOrder
    course_id?: SortOrder
    material_ingo?: SortOrder
  }

  export type MaterialsSumOrderByAggregateInput = {
    material_id?: SortOrder
    course_id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TestStatusListRelationFilter = {
    every?: TestStatusWhereInput
    some?: TestStatusWhereInput
    none?: TestStatusWhereInput
  }

  export type TestStatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentsCountOrderByAggregateInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    balance?: SortOrder
    email?: SortOrder
    user_password?: SortOrder
  }

  export type StudentsAvgOrderByAggregateInput = {
    user_ident?: SortOrder
    balance?: SortOrder
  }

  export type StudentsMaxOrderByAggregateInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    balance?: SortOrder
    email?: SortOrder
    user_password?: SortOrder
  }

  export type StudentsMinOrderByAggregateInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    balance?: SortOrder
    email?: SortOrder
    user_password?: SortOrder
  }

  export type StudentsSumOrderByAggregateInput = {
    user_ident?: SortOrder
    balance?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StudentsRelationFilter = {
    is?: StudentsWhereInput
    isNot?: StudentsWhereInput
  }

  export type StudentToCourseCountOrderByAggregateInput = {
    STC_id?: SortOrder
    course_id?: SortOrder
    student_id?: SortOrder
  }

  export type StudentToCourseAvgOrderByAggregateInput = {
    STC_id?: SortOrder
    course_id?: SortOrder
    student_id?: SortOrder
  }

  export type StudentToCourseMaxOrderByAggregateInput = {
    STC_id?: SortOrder
    course_id?: SortOrder
    student_id?: SortOrder
  }

  export type StudentToCourseMinOrderByAggregateInput = {
    STC_id?: SortOrder
    course_id?: SortOrder
    student_id?: SortOrder
  }

  export type StudentToCourseSumOrderByAggregateInput = {
    STC_id?: SortOrder
    course_id?: SortOrder
    student_id?: SortOrder
  }

  export type TeachersCountOrderByAggregateInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    email?: SortOrder
    user_password?: SortOrder
    descipline?: SortOrder
  }

  export type TeachersAvgOrderByAggregateInput = {
    user_ident?: SortOrder
  }

  export type TeachersMaxOrderByAggregateInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    email?: SortOrder
    user_password?: SortOrder
    descipline?: SortOrder
  }

  export type TeachersMinOrderByAggregateInput = {
    user_ident?: SortOrder
    fio?: SortOrder
    email?: SortOrder
    user_password?: SortOrder
    descipline?: SortOrder
  }

  export type TeachersSumOrderByAggregateInput = {
    user_ident?: SortOrder
  }

  export type TeachersRelationFilter = {
    is?: TeachersWhereInput
    isNot?: TeachersWhereInput
  }

  export type TeacherToCourseCountOrderByAggregateInput = {
    TTC_id?: SortOrder
    teacher_id?: SortOrder
    course_id?: SortOrder
  }

  export type TeacherToCourseAvgOrderByAggregateInput = {
    TTC_id?: SortOrder
    teacher_id?: SortOrder
    course_id?: SortOrder
  }

  export type TeacherToCourseMaxOrderByAggregateInput = {
    TTC_id?: SortOrder
    teacher_id?: SortOrder
    course_id?: SortOrder
  }

  export type TeacherToCourseMinOrderByAggregateInput = {
    TTC_id?: SortOrder
    teacher_id?: SortOrder
    course_id?: SortOrder
  }

  export type TeacherToCourseSumOrderByAggregateInput = {
    TTC_id?: SortOrder
    teacher_id?: SortOrder
    course_id?: SortOrder
  }

  export type AnswersListRelationFilter = {
    every?: AnswersWhereInput
    some?: AnswersWhereInput
    none?: AnswersWhereInput
  }

  export type AnswersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestsCountOrderByAggregateInput = {
    test_id?: SortOrder
    test_name?: SortOrder
    test_desc?: SortOrder
    course_id?: SortOrder
  }

  export type TestsAvgOrderByAggregateInput = {
    test_id?: SortOrder
    course_id?: SortOrder
  }

  export type TestsMaxOrderByAggregateInput = {
    test_id?: SortOrder
    test_name?: SortOrder
    test_desc?: SortOrder
    course_id?: SortOrder
  }

  export type TestsMinOrderByAggregateInput = {
    test_id?: SortOrder
    test_name?: SortOrder
    test_desc?: SortOrder
    course_id?: SortOrder
  }

  export type TestsSumOrderByAggregateInput = {
    test_id?: SortOrder
    course_id?: SortOrder
  }

  export type TestStatusCountOrderByAggregateInput = {
    status_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
  }

  export type TestStatusAvgOrderByAggregateInput = {
    status_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
  }

  export type TestStatusMaxOrderByAggregateInput = {
    status_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
  }

  export type TestStatusMinOrderByAggregateInput = {
    status_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
  }

  export type TestStatusSumOrderByAggregateInput = {
    status_id?: SortOrder
    test_id?: SortOrder
    student_id?: SortOrder
  }

  export type TestsCreateNestedOneWithoutAnswersInput = {
    create?: XOR<TestsCreateWithoutAnswersInput, TestsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: TestsCreateOrConnectWithoutAnswersInput
    connect?: TestsWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type TestsUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<TestsCreateWithoutAnswersInput, TestsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: TestsCreateOrConnectWithoutAnswersInput
    upsert?: TestsUpsertWithoutAnswersInput
    connect?: TestsWhereUniqueInput
    update?: XOR<XOR<TestsUpdateToOneWithWhereWithoutAnswersInput, TestsUpdateWithoutAnswersInput>, TestsUncheckedUpdateWithoutAnswersInput>
  }

  export type DesciplinesCreateNestedOneWithoutCoursesInput = {
    create?: XOR<DesciplinesCreateWithoutCoursesInput, DesciplinesUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: DesciplinesCreateOrConnectWithoutCoursesInput
    connect?: DesciplinesWhereUniqueInput
  }

  export type MaterialsCreateNestedManyWithoutCoursesInput = {
    create?: XOR<MaterialsCreateWithoutCoursesInput, MaterialsUncheckedCreateWithoutCoursesInput> | MaterialsCreateWithoutCoursesInput[] | MaterialsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: MaterialsCreateOrConnectWithoutCoursesInput | MaterialsCreateOrConnectWithoutCoursesInput[]
    createMany?: MaterialsCreateManyCoursesInputEnvelope
    connect?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
  }

  export type StudentToCourseCreateNestedManyWithoutCoursesInput = {
    create?: XOR<StudentToCourseCreateWithoutCoursesInput, StudentToCourseUncheckedCreateWithoutCoursesInput> | StudentToCourseCreateWithoutCoursesInput[] | StudentToCourseUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: StudentToCourseCreateOrConnectWithoutCoursesInput | StudentToCourseCreateOrConnectWithoutCoursesInput[]
    createMany?: StudentToCourseCreateManyCoursesInputEnvelope
    connect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
  }

  export type TeacherToCourseCreateNestedManyWithoutCoursesInput = {
    create?: XOR<TeacherToCourseCreateWithoutCoursesInput, TeacherToCourseUncheckedCreateWithoutCoursesInput> | TeacherToCourseCreateWithoutCoursesInput[] | TeacherToCourseUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: TeacherToCourseCreateOrConnectWithoutCoursesInput | TeacherToCourseCreateOrConnectWithoutCoursesInput[]
    createMany?: TeacherToCourseCreateManyCoursesInputEnvelope
    connect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
  }

  export type TestsCreateNestedManyWithoutCoursesInput = {
    create?: XOR<TestsCreateWithoutCoursesInput, TestsUncheckedCreateWithoutCoursesInput> | TestsCreateWithoutCoursesInput[] | TestsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: TestsCreateOrConnectWithoutCoursesInput | TestsCreateOrConnectWithoutCoursesInput[]
    createMany?: TestsCreateManyCoursesInputEnvelope
    connect?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
  }

  export type MaterialsUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<MaterialsCreateWithoutCoursesInput, MaterialsUncheckedCreateWithoutCoursesInput> | MaterialsCreateWithoutCoursesInput[] | MaterialsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: MaterialsCreateOrConnectWithoutCoursesInput | MaterialsCreateOrConnectWithoutCoursesInput[]
    createMany?: MaterialsCreateManyCoursesInputEnvelope
    connect?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
  }

  export type StudentToCourseUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<StudentToCourseCreateWithoutCoursesInput, StudentToCourseUncheckedCreateWithoutCoursesInput> | StudentToCourseCreateWithoutCoursesInput[] | StudentToCourseUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: StudentToCourseCreateOrConnectWithoutCoursesInput | StudentToCourseCreateOrConnectWithoutCoursesInput[]
    createMany?: StudentToCourseCreateManyCoursesInputEnvelope
    connect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
  }

  export type TeacherToCourseUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<TeacherToCourseCreateWithoutCoursesInput, TeacherToCourseUncheckedCreateWithoutCoursesInput> | TeacherToCourseCreateWithoutCoursesInput[] | TeacherToCourseUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: TeacherToCourseCreateOrConnectWithoutCoursesInput | TeacherToCourseCreateOrConnectWithoutCoursesInput[]
    createMany?: TeacherToCourseCreateManyCoursesInputEnvelope
    connect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
  }

  export type TestsUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<TestsCreateWithoutCoursesInput, TestsUncheckedCreateWithoutCoursesInput> | TestsCreateWithoutCoursesInput[] | TestsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: TestsCreateOrConnectWithoutCoursesInput | TestsCreateOrConnectWithoutCoursesInput[]
    createMany?: TestsCreateManyCoursesInputEnvelope
    connect?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DesciplinesUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<DesciplinesCreateWithoutCoursesInput, DesciplinesUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: DesciplinesCreateOrConnectWithoutCoursesInput
    upsert?: DesciplinesUpsertWithoutCoursesInput
    connect?: DesciplinesWhereUniqueInput
    update?: XOR<XOR<DesciplinesUpdateToOneWithWhereWithoutCoursesInput, DesciplinesUpdateWithoutCoursesInput>, DesciplinesUncheckedUpdateWithoutCoursesInput>
  }

  export type MaterialsUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<MaterialsCreateWithoutCoursesInput, MaterialsUncheckedCreateWithoutCoursesInput> | MaterialsCreateWithoutCoursesInput[] | MaterialsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: MaterialsCreateOrConnectWithoutCoursesInput | MaterialsCreateOrConnectWithoutCoursesInput[]
    upsert?: MaterialsUpsertWithWhereUniqueWithoutCoursesInput | MaterialsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: MaterialsCreateManyCoursesInputEnvelope
    set?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
    disconnect?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
    delete?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
    connect?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
    update?: MaterialsUpdateWithWhereUniqueWithoutCoursesInput | MaterialsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: MaterialsUpdateManyWithWhereWithoutCoursesInput | MaterialsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: MaterialsScalarWhereInput | MaterialsScalarWhereInput[]
  }

  export type StudentToCourseUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<StudentToCourseCreateWithoutCoursesInput, StudentToCourseUncheckedCreateWithoutCoursesInput> | StudentToCourseCreateWithoutCoursesInput[] | StudentToCourseUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: StudentToCourseCreateOrConnectWithoutCoursesInput | StudentToCourseCreateOrConnectWithoutCoursesInput[]
    upsert?: StudentToCourseUpsertWithWhereUniqueWithoutCoursesInput | StudentToCourseUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: StudentToCourseCreateManyCoursesInputEnvelope
    set?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    disconnect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    delete?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    connect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    update?: StudentToCourseUpdateWithWhereUniqueWithoutCoursesInput | StudentToCourseUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: StudentToCourseUpdateManyWithWhereWithoutCoursesInput | StudentToCourseUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: StudentToCourseScalarWhereInput | StudentToCourseScalarWhereInput[]
  }

  export type TeacherToCourseUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<TeacherToCourseCreateWithoutCoursesInput, TeacherToCourseUncheckedCreateWithoutCoursesInput> | TeacherToCourseCreateWithoutCoursesInput[] | TeacherToCourseUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: TeacherToCourseCreateOrConnectWithoutCoursesInput | TeacherToCourseCreateOrConnectWithoutCoursesInput[]
    upsert?: TeacherToCourseUpsertWithWhereUniqueWithoutCoursesInput | TeacherToCourseUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: TeacherToCourseCreateManyCoursesInputEnvelope
    set?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    disconnect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    delete?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    connect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    update?: TeacherToCourseUpdateWithWhereUniqueWithoutCoursesInput | TeacherToCourseUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: TeacherToCourseUpdateManyWithWhereWithoutCoursesInput | TeacherToCourseUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: TeacherToCourseScalarWhereInput | TeacherToCourseScalarWhereInput[]
  }

  export type TestsUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<TestsCreateWithoutCoursesInput, TestsUncheckedCreateWithoutCoursesInput> | TestsCreateWithoutCoursesInput[] | TestsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: TestsCreateOrConnectWithoutCoursesInput | TestsCreateOrConnectWithoutCoursesInput[]
    upsert?: TestsUpsertWithWhereUniqueWithoutCoursesInput | TestsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: TestsCreateManyCoursesInputEnvelope
    set?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
    disconnect?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
    delete?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
    connect?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
    update?: TestsUpdateWithWhereUniqueWithoutCoursesInput | TestsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: TestsUpdateManyWithWhereWithoutCoursesInput | TestsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: TestsScalarWhereInput | TestsScalarWhereInput[]
  }

  export type MaterialsUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<MaterialsCreateWithoutCoursesInput, MaterialsUncheckedCreateWithoutCoursesInput> | MaterialsCreateWithoutCoursesInput[] | MaterialsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: MaterialsCreateOrConnectWithoutCoursesInput | MaterialsCreateOrConnectWithoutCoursesInput[]
    upsert?: MaterialsUpsertWithWhereUniqueWithoutCoursesInput | MaterialsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: MaterialsCreateManyCoursesInputEnvelope
    set?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
    disconnect?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
    delete?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
    connect?: MaterialsWhereUniqueInput | MaterialsWhereUniqueInput[]
    update?: MaterialsUpdateWithWhereUniqueWithoutCoursesInput | MaterialsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: MaterialsUpdateManyWithWhereWithoutCoursesInput | MaterialsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: MaterialsScalarWhereInput | MaterialsScalarWhereInput[]
  }

  export type StudentToCourseUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<StudentToCourseCreateWithoutCoursesInput, StudentToCourseUncheckedCreateWithoutCoursesInput> | StudentToCourseCreateWithoutCoursesInput[] | StudentToCourseUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: StudentToCourseCreateOrConnectWithoutCoursesInput | StudentToCourseCreateOrConnectWithoutCoursesInput[]
    upsert?: StudentToCourseUpsertWithWhereUniqueWithoutCoursesInput | StudentToCourseUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: StudentToCourseCreateManyCoursesInputEnvelope
    set?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    disconnect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    delete?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    connect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    update?: StudentToCourseUpdateWithWhereUniqueWithoutCoursesInput | StudentToCourseUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: StudentToCourseUpdateManyWithWhereWithoutCoursesInput | StudentToCourseUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: StudentToCourseScalarWhereInput | StudentToCourseScalarWhereInput[]
  }

  export type TeacherToCourseUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<TeacherToCourseCreateWithoutCoursesInput, TeacherToCourseUncheckedCreateWithoutCoursesInput> | TeacherToCourseCreateWithoutCoursesInput[] | TeacherToCourseUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: TeacherToCourseCreateOrConnectWithoutCoursesInput | TeacherToCourseCreateOrConnectWithoutCoursesInput[]
    upsert?: TeacherToCourseUpsertWithWhereUniqueWithoutCoursesInput | TeacherToCourseUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: TeacherToCourseCreateManyCoursesInputEnvelope
    set?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    disconnect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    delete?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    connect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    update?: TeacherToCourseUpdateWithWhereUniqueWithoutCoursesInput | TeacherToCourseUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: TeacherToCourseUpdateManyWithWhereWithoutCoursesInput | TeacherToCourseUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: TeacherToCourseScalarWhereInput | TeacherToCourseScalarWhereInput[]
  }

  export type TestsUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<TestsCreateWithoutCoursesInput, TestsUncheckedCreateWithoutCoursesInput> | TestsCreateWithoutCoursesInput[] | TestsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: TestsCreateOrConnectWithoutCoursesInput | TestsCreateOrConnectWithoutCoursesInput[]
    upsert?: TestsUpsertWithWhereUniqueWithoutCoursesInput | TestsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: TestsCreateManyCoursesInputEnvelope
    set?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
    disconnect?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
    delete?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
    connect?: TestsWhereUniqueInput | TestsWhereUniqueInput[]
    update?: TestsUpdateWithWhereUniqueWithoutCoursesInput | TestsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: TestsUpdateManyWithWhereWithoutCoursesInput | TestsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: TestsScalarWhereInput | TestsScalarWhereInput[]
  }

  export type CoursesCreateNestedManyWithoutDesciplinesInput = {
    create?: XOR<CoursesCreateWithoutDesciplinesInput, CoursesUncheckedCreateWithoutDesciplinesInput> | CoursesCreateWithoutDesciplinesInput[] | CoursesUncheckedCreateWithoutDesciplinesInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutDesciplinesInput | CoursesCreateOrConnectWithoutDesciplinesInput[]
    createMany?: CoursesCreateManyDesciplinesInputEnvelope
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
  }

  export type TeachersCreateNestedManyWithoutDesciplinesInput = {
    create?: XOR<TeachersCreateWithoutDesciplinesInput, TeachersUncheckedCreateWithoutDesciplinesInput> | TeachersCreateWithoutDesciplinesInput[] | TeachersUncheckedCreateWithoutDesciplinesInput[]
    connectOrCreate?: TeachersCreateOrConnectWithoutDesciplinesInput | TeachersCreateOrConnectWithoutDesciplinesInput[]
    createMany?: TeachersCreateManyDesciplinesInputEnvelope
    connect?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
  }

  export type CoursesUncheckedCreateNestedManyWithoutDesciplinesInput = {
    create?: XOR<CoursesCreateWithoutDesciplinesInput, CoursesUncheckedCreateWithoutDesciplinesInput> | CoursesCreateWithoutDesciplinesInput[] | CoursesUncheckedCreateWithoutDesciplinesInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutDesciplinesInput | CoursesCreateOrConnectWithoutDesciplinesInput[]
    createMany?: CoursesCreateManyDesciplinesInputEnvelope
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
  }

  export type TeachersUncheckedCreateNestedManyWithoutDesciplinesInput = {
    create?: XOR<TeachersCreateWithoutDesciplinesInput, TeachersUncheckedCreateWithoutDesciplinesInput> | TeachersCreateWithoutDesciplinesInput[] | TeachersUncheckedCreateWithoutDesciplinesInput[]
    connectOrCreate?: TeachersCreateOrConnectWithoutDesciplinesInput | TeachersCreateOrConnectWithoutDesciplinesInput[]
    createMany?: TeachersCreateManyDesciplinesInputEnvelope
    connect?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
  }

  export type CoursesUpdateManyWithoutDesciplinesNestedInput = {
    create?: XOR<CoursesCreateWithoutDesciplinesInput, CoursesUncheckedCreateWithoutDesciplinesInput> | CoursesCreateWithoutDesciplinesInput[] | CoursesUncheckedCreateWithoutDesciplinesInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutDesciplinesInput | CoursesCreateOrConnectWithoutDesciplinesInput[]
    upsert?: CoursesUpsertWithWhereUniqueWithoutDesciplinesInput | CoursesUpsertWithWhereUniqueWithoutDesciplinesInput[]
    createMany?: CoursesCreateManyDesciplinesInputEnvelope
    set?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    disconnect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    delete?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    update?: CoursesUpdateWithWhereUniqueWithoutDesciplinesInput | CoursesUpdateWithWhereUniqueWithoutDesciplinesInput[]
    updateMany?: CoursesUpdateManyWithWhereWithoutDesciplinesInput | CoursesUpdateManyWithWhereWithoutDesciplinesInput[]
    deleteMany?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
  }

  export type TeachersUpdateManyWithoutDesciplinesNestedInput = {
    create?: XOR<TeachersCreateWithoutDesciplinesInput, TeachersUncheckedCreateWithoutDesciplinesInput> | TeachersCreateWithoutDesciplinesInput[] | TeachersUncheckedCreateWithoutDesciplinesInput[]
    connectOrCreate?: TeachersCreateOrConnectWithoutDesciplinesInput | TeachersCreateOrConnectWithoutDesciplinesInput[]
    upsert?: TeachersUpsertWithWhereUniqueWithoutDesciplinesInput | TeachersUpsertWithWhereUniqueWithoutDesciplinesInput[]
    createMany?: TeachersCreateManyDesciplinesInputEnvelope
    set?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
    disconnect?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
    delete?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
    connect?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
    update?: TeachersUpdateWithWhereUniqueWithoutDesciplinesInput | TeachersUpdateWithWhereUniqueWithoutDesciplinesInput[]
    updateMany?: TeachersUpdateManyWithWhereWithoutDesciplinesInput | TeachersUpdateManyWithWhereWithoutDesciplinesInput[]
    deleteMany?: TeachersScalarWhereInput | TeachersScalarWhereInput[]
  }

  export type CoursesUncheckedUpdateManyWithoutDesciplinesNestedInput = {
    create?: XOR<CoursesCreateWithoutDesciplinesInput, CoursesUncheckedCreateWithoutDesciplinesInput> | CoursesCreateWithoutDesciplinesInput[] | CoursesUncheckedCreateWithoutDesciplinesInput[]
    connectOrCreate?: CoursesCreateOrConnectWithoutDesciplinesInput | CoursesCreateOrConnectWithoutDesciplinesInput[]
    upsert?: CoursesUpsertWithWhereUniqueWithoutDesciplinesInput | CoursesUpsertWithWhereUniqueWithoutDesciplinesInput[]
    createMany?: CoursesCreateManyDesciplinesInputEnvelope
    set?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    disconnect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    delete?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    connect?: CoursesWhereUniqueInput | CoursesWhereUniqueInput[]
    update?: CoursesUpdateWithWhereUniqueWithoutDesciplinesInput | CoursesUpdateWithWhereUniqueWithoutDesciplinesInput[]
    updateMany?: CoursesUpdateManyWithWhereWithoutDesciplinesInput | CoursesUpdateManyWithWhereWithoutDesciplinesInput[]
    deleteMany?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
  }

  export type TeachersUncheckedUpdateManyWithoutDesciplinesNestedInput = {
    create?: XOR<TeachersCreateWithoutDesciplinesInput, TeachersUncheckedCreateWithoutDesciplinesInput> | TeachersCreateWithoutDesciplinesInput[] | TeachersUncheckedCreateWithoutDesciplinesInput[]
    connectOrCreate?: TeachersCreateOrConnectWithoutDesciplinesInput | TeachersCreateOrConnectWithoutDesciplinesInput[]
    upsert?: TeachersUpsertWithWhereUniqueWithoutDesciplinesInput | TeachersUpsertWithWhereUniqueWithoutDesciplinesInput[]
    createMany?: TeachersCreateManyDesciplinesInputEnvelope
    set?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
    disconnect?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
    delete?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
    connect?: TeachersWhereUniqueInput | TeachersWhereUniqueInput[]
    update?: TeachersUpdateWithWhereUniqueWithoutDesciplinesInput | TeachersUpdateWithWhereUniqueWithoutDesciplinesInput[]
    updateMany?: TeachersUpdateManyWithWhereWithoutDesciplinesInput | TeachersUpdateManyWithWhereWithoutDesciplinesInput[]
    deleteMany?: TeachersScalarWhereInput | TeachersScalarWhereInput[]
  }

  export type CoursesCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<CoursesCreateWithoutMaterialsInput, CoursesUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutMaterialsInput
    connect?: CoursesWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<CoursesCreateWithoutMaterialsInput, CoursesUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutMaterialsInput
    upsert?: CoursesUpsertWithoutMaterialsInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutMaterialsInput, CoursesUpdateWithoutMaterialsInput>, CoursesUncheckedUpdateWithoutMaterialsInput>
  }

  export type StudentToCourseCreateNestedManyWithoutStudentsInput = {
    create?: XOR<StudentToCourseCreateWithoutStudentsInput, StudentToCourseUncheckedCreateWithoutStudentsInput> | StudentToCourseCreateWithoutStudentsInput[] | StudentToCourseUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: StudentToCourseCreateOrConnectWithoutStudentsInput | StudentToCourseCreateOrConnectWithoutStudentsInput[]
    createMany?: StudentToCourseCreateManyStudentsInputEnvelope
    connect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
  }

  export type TestStatusCreateNestedManyWithoutStudentsInput = {
    create?: XOR<TestStatusCreateWithoutStudentsInput, TestStatusUncheckedCreateWithoutStudentsInput> | TestStatusCreateWithoutStudentsInput[] | TestStatusUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: TestStatusCreateOrConnectWithoutStudentsInput | TestStatusCreateOrConnectWithoutStudentsInput[]
    createMany?: TestStatusCreateManyStudentsInputEnvelope
    connect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
  }

  export type StudentToCourseUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<StudentToCourseCreateWithoutStudentsInput, StudentToCourseUncheckedCreateWithoutStudentsInput> | StudentToCourseCreateWithoutStudentsInput[] | StudentToCourseUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: StudentToCourseCreateOrConnectWithoutStudentsInput | StudentToCourseCreateOrConnectWithoutStudentsInput[]
    createMany?: StudentToCourseCreateManyStudentsInputEnvelope
    connect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
  }

  export type TestStatusUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<TestStatusCreateWithoutStudentsInput, TestStatusUncheckedCreateWithoutStudentsInput> | TestStatusCreateWithoutStudentsInput[] | TestStatusUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: TestStatusCreateOrConnectWithoutStudentsInput | TestStatusCreateOrConnectWithoutStudentsInput[]
    createMany?: TestStatusCreateManyStudentsInputEnvelope
    connect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentToCourseUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<StudentToCourseCreateWithoutStudentsInput, StudentToCourseUncheckedCreateWithoutStudentsInput> | StudentToCourseCreateWithoutStudentsInput[] | StudentToCourseUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: StudentToCourseCreateOrConnectWithoutStudentsInput | StudentToCourseCreateOrConnectWithoutStudentsInput[]
    upsert?: StudentToCourseUpsertWithWhereUniqueWithoutStudentsInput | StudentToCourseUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: StudentToCourseCreateManyStudentsInputEnvelope
    set?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    disconnect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    delete?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    connect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    update?: StudentToCourseUpdateWithWhereUniqueWithoutStudentsInput | StudentToCourseUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: StudentToCourseUpdateManyWithWhereWithoutStudentsInput | StudentToCourseUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: StudentToCourseScalarWhereInput | StudentToCourseScalarWhereInput[]
  }

  export type TestStatusUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<TestStatusCreateWithoutStudentsInput, TestStatusUncheckedCreateWithoutStudentsInput> | TestStatusCreateWithoutStudentsInput[] | TestStatusUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: TestStatusCreateOrConnectWithoutStudentsInput | TestStatusCreateOrConnectWithoutStudentsInput[]
    upsert?: TestStatusUpsertWithWhereUniqueWithoutStudentsInput | TestStatusUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: TestStatusCreateManyStudentsInputEnvelope
    set?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    disconnect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    delete?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    connect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    update?: TestStatusUpdateWithWhereUniqueWithoutStudentsInput | TestStatusUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: TestStatusUpdateManyWithWhereWithoutStudentsInput | TestStatusUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: TestStatusScalarWhereInput | TestStatusScalarWhereInput[]
  }

  export type StudentToCourseUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<StudentToCourseCreateWithoutStudentsInput, StudentToCourseUncheckedCreateWithoutStudentsInput> | StudentToCourseCreateWithoutStudentsInput[] | StudentToCourseUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: StudentToCourseCreateOrConnectWithoutStudentsInput | StudentToCourseCreateOrConnectWithoutStudentsInput[]
    upsert?: StudentToCourseUpsertWithWhereUniqueWithoutStudentsInput | StudentToCourseUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: StudentToCourseCreateManyStudentsInputEnvelope
    set?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    disconnect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    delete?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    connect?: StudentToCourseWhereUniqueInput | StudentToCourseWhereUniqueInput[]
    update?: StudentToCourseUpdateWithWhereUniqueWithoutStudentsInput | StudentToCourseUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: StudentToCourseUpdateManyWithWhereWithoutStudentsInput | StudentToCourseUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: StudentToCourseScalarWhereInput | StudentToCourseScalarWhereInput[]
  }

  export type TestStatusUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<TestStatusCreateWithoutStudentsInput, TestStatusUncheckedCreateWithoutStudentsInput> | TestStatusCreateWithoutStudentsInput[] | TestStatusUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: TestStatusCreateOrConnectWithoutStudentsInput | TestStatusCreateOrConnectWithoutStudentsInput[]
    upsert?: TestStatusUpsertWithWhereUniqueWithoutStudentsInput | TestStatusUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: TestStatusCreateManyStudentsInputEnvelope
    set?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    disconnect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    delete?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    connect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    update?: TestStatusUpdateWithWhereUniqueWithoutStudentsInput | TestStatusUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: TestStatusUpdateManyWithWhereWithoutStudentsInput | TestStatusUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: TestStatusScalarWhereInput | TestStatusScalarWhereInput[]
  }

  export type CoursesCreateNestedOneWithoutStudentToCourseInput = {
    create?: XOR<CoursesCreateWithoutStudentToCourseInput, CoursesUncheckedCreateWithoutStudentToCourseInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutStudentToCourseInput
    connect?: CoursesWhereUniqueInput
  }

  export type StudentsCreateNestedOneWithoutStudentToCourseInput = {
    create?: XOR<StudentsCreateWithoutStudentToCourseInput, StudentsUncheckedCreateWithoutStudentToCourseInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutStudentToCourseInput
    connect?: StudentsWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutStudentToCourseNestedInput = {
    create?: XOR<CoursesCreateWithoutStudentToCourseInput, CoursesUncheckedCreateWithoutStudentToCourseInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutStudentToCourseInput
    upsert?: CoursesUpsertWithoutStudentToCourseInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutStudentToCourseInput, CoursesUpdateWithoutStudentToCourseInput>, CoursesUncheckedUpdateWithoutStudentToCourseInput>
  }

  export type StudentsUpdateOneRequiredWithoutStudentToCourseNestedInput = {
    create?: XOR<StudentsCreateWithoutStudentToCourseInput, StudentsUncheckedCreateWithoutStudentToCourseInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutStudentToCourseInput
    upsert?: StudentsUpsertWithoutStudentToCourseInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutStudentToCourseInput, StudentsUpdateWithoutStudentToCourseInput>, StudentsUncheckedUpdateWithoutStudentToCourseInput>
  }

  export type DesciplinesCreateNestedOneWithoutTeachersInput = {
    create?: XOR<DesciplinesCreateWithoutTeachersInput, DesciplinesUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: DesciplinesCreateOrConnectWithoutTeachersInput
    connect?: DesciplinesWhereUniqueInput
  }

  export type TeacherToCourseCreateNestedManyWithoutTeachersInput = {
    create?: XOR<TeacherToCourseCreateWithoutTeachersInput, TeacherToCourseUncheckedCreateWithoutTeachersInput> | TeacherToCourseCreateWithoutTeachersInput[] | TeacherToCourseUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: TeacherToCourseCreateOrConnectWithoutTeachersInput | TeacherToCourseCreateOrConnectWithoutTeachersInput[]
    createMany?: TeacherToCourseCreateManyTeachersInputEnvelope
    connect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
  }

  export type TeacherToCourseUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<TeacherToCourseCreateWithoutTeachersInput, TeacherToCourseUncheckedCreateWithoutTeachersInput> | TeacherToCourseCreateWithoutTeachersInput[] | TeacherToCourseUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: TeacherToCourseCreateOrConnectWithoutTeachersInput | TeacherToCourseCreateOrConnectWithoutTeachersInput[]
    createMany?: TeacherToCourseCreateManyTeachersInputEnvelope
    connect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
  }

  export type DesciplinesUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<DesciplinesCreateWithoutTeachersInput, DesciplinesUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: DesciplinesCreateOrConnectWithoutTeachersInput
    upsert?: DesciplinesUpsertWithoutTeachersInput
    connect?: DesciplinesWhereUniqueInput
    update?: XOR<XOR<DesciplinesUpdateToOneWithWhereWithoutTeachersInput, DesciplinesUpdateWithoutTeachersInput>, DesciplinesUncheckedUpdateWithoutTeachersInput>
  }

  export type TeacherToCourseUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<TeacherToCourseCreateWithoutTeachersInput, TeacherToCourseUncheckedCreateWithoutTeachersInput> | TeacherToCourseCreateWithoutTeachersInput[] | TeacherToCourseUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: TeacherToCourseCreateOrConnectWithoutTeachersInput | TeacherToCourseCreateOrConnectWithoutTeachersInput[]
    upsert?: TeacherToCourseUpsertWithWhereUniqueWithoutTeachersInput | TeacherToCourseUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: TeacherToCourseCreateManyTeachersInputEnvelope
    set?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    disconnect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    delete?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    connect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    update?: TeacherToCourseUpdateWithWhereUniqueWithoutTeachersInput | TeacherToCourseUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: TeacherToCourseUpdateManyWithWhereWithoutTeachersInput | TeacherToCourseUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: TeacherToCourseScalarWhereInput | TeacherToCourseScalarWhereInput[]
  }

  export type TeacherToCourseUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<TeacherToCourseCreateWithoutTeachersInput, TeacherToCourseUncheckedCreateWithoutTeachersInput> | TeacherToCourseCreateWithoutTeachersInput[] | TeacherToCourseUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: TeacherToCourseCreateOrConnectWithoutTeachersInput | TeacherToCourseCreateOrConnectWithoutTeachersInput[]
    upsert?: TeacherToCourseUpsertWithWhereUniqueWithoutTeachersInput | TeacherToCourseUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: TeacherToCourseCreateManyTeachersInputEnvelope
    set?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    disconnect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    delete?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    connect?: TeacherToCourseWhereUniqueInput | TeacherToCourseWhereUniqueInput[]
    update?: TeacherToCourseUpdateWithWhereUniqueWithoutTeachersInput | TeacherToCourseUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: TeacherToCourseUpdateManyWithWhereWithoutTeachersInput | TeacherToCourseUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: TeacherToCourseScalarWhereInput | TeacherToCourseScalarWhereInput[]
  }

  export type CoursesCreateNestedOneWithoutTeacherToCourseInput = {
    create?: XOR<CoursesCreateWithoutTeacherToCourseInput, CoursesUncheckedCreateWithoutTeacherToCourseInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutTeacherToCourseInput
    connect?: CoursesWhereUniqueInput
  }

  export type TeachersCreateNestedOneWithoutTeacherToCourseInput = {
    create?: XOR<TeachersCreateWithoutTeacherToCourseInput, TeachersUncheckedCreateWithoutTeacherToCourseInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutTeacherToCourseInput
    connect?: TeachersWhereUniqueInput
  }

  export type CoursesUpdateOneRequiredWithoutTeacherToCourseNestedInput = {
    create?: XOR<CoursesCreateWithoutTeacherToCourseInput, CoursesUncheckedCreateWithoutTeacherToCourseInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutTeacherToCourseInput
    upsert?: CoursesUpsertWithoutTeacherToCourseInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutTeacherToCourseInput, CoursesUpdateWithoutTeacherToCourseInput>, CoursesUncheckedUpdateWithoutTeacherToCourseInput>
  }

  export type TeachersUpdateOneRequiredWithoutTeacherToCourseNestedInput = {
    create?: XOR<TeachersCreateWithoutTeacherToCourseInput, TeachersUncheckedCreateWithoutTeacherToCourseInput>
    connectOrCreate?: TeachersCreateOrConnectWithoutTeacherToCourseInput
    upsert?: TeachersUpsertWithoutTeacherToCourseInput
    connect?: TeachersWhereUniqueInput
    update?: XOR<XOR<TeachersUpdateToOneWithWhereWithoutTeacherToCourseInput, TeachersUpdateWithoutTeacherToCourseInput>, TeachersUncheckedUpdateWithoutTeacherToCourseInput>
  }

  export type AnswersCreateNestedManyWithoutTestsInput = {
    create?: XOR<AnswersCreateWithoutTestsInput, AnswersUncheckedCreateWithoutTestsInput> | AnswersCreateWithoutTestsInput[] | AnswersUncheckedCreateWithoutTestsInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutTestsInput | AnswersCreateOrConnectWithoutTestsInput[]
    createMany?: AnswersCreateManyTestsInputEnvelope
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
  }

  export type CoursesCreateNestedOneWithoutTestsInput = {
    create?: XOR<CoursesCreateWithoutTestsInput, CoursesUncheckedCreateWithoutTestsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutTestsInput
    connect?: CoursesWhereUniqueInput
  }

  export type TestStatusCreateNestedManyWithoutTestsInput = {
    create?: XOR<TestStatusCreateWithoutTestsInput, TestStatusUncheckedCreateWithoutTestsInput> | TestStatusCreateWithoutTestsInput[] | TestStatusUncheckedCreateWithoutTestsInput[]
    connectOrCreate?: TestStatusCreateOrConnectWithoutTestsInput | TestStatusCreateOrConnectWithoutTestsInput[]
    createMany?: TestStatusCreateManyTestsInputEnvelope
    connect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
  }

  export type AnswersUncheckedCreateNestedManyWithoutTestsInput = {
    create?: XOR<AnswersCreateWithoutTestsInput, AnswersUncheckedCreateWithoutTestsInput> | AnswersCreateWithoutTestsInput[] | AnswersUncheckedCreateWithoutTestsInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutTestsInput | AnswersCreateOrConnectWithoutTestsInput[]
    createMany?: AnswersCreateManyTestsInputEnvelope
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
  }

  export type TestStatusUncheckedCreateNestedManyWithoutTestsInput = {
    create?: XOR<TestStatusCreateWithoutTestsInput, TestStatusUncheckedCreateWithoutTestsInput> | TestStatusCreateWithoutTestsInput[] | TestStatusUncheckedCreateWithoutTestsInput[]
    connectOrCreate?: TestStatusCreateOrConnectWithoutTestsInput | TestStatusCreateOrConnectWithoutTestsInput[]
    createMany?: TestStatusCreateManyTestsInputEnvelope
    connect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
  }

  export type AnswersUpdateManyWithoutTestsNestedInput = {
    create?: XOR<AnswersCreateWithoutTestsInput, AnswersUncheckedCreateWithoutTestsInput> | AnswersCreateWithoutTestsInput[] | AnswersUncheckedCreateWithoutTestsInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutTestsInput | AnswersCreateOrConnectWithoutTestsInput[]
    upsert?: AnswersUpsertWithWhereUniqueWithoutTestsInput | AnswersUpsertWithWhereUniqueWithoutTestsInput[]
    createMany?: AnswersCreateManyTestsInputEnvelope
    set?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    disconnect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    delete?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    update?: AnswersUpdateWithWhereUniqueWithoutTestsInput | AnswersUpdateWithWhereUniqueWithoutTestsInput[]
    updateMany?: AnswersUpdateManyWithWhereWithoutTestsInput | AnswersUpdateManyWithWhereWithoutTestsInput[]
    deleteMany?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
  }

  export type CoursesUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<CoursesCreateWithoutTestsInput, CoursesUncheckedCreateWithoutTestsInput>
    connectOrCreate?: CoursesCreateOrConnectWithoutTestsInput
    upsert?: CoursesUpsertWithoutTestsInput
    connect?: CoursesWhereUniqueInput
    update?: XOR<XOR<CoursesUpdateToOneWithWhereWithoutTestsInput, CoursesUpdateWithoutTestsInput>, CoursesUncheckedUpdateWithoutTestsInput>
  }

  export type TestStatusUpdateManyWithoutTestsNestedInput = {
    create?: XOR<TestStatusCreateWithoutTestsInput, TestStatusUncheckedCreateWithoutTestsInput> | TestStatusCreateWithoutTestsInput[] | TestStatusUncheckedCreateWithoutTestsInput[]
    connectOrCreate?: TestStatusCreateOrConnectWithoutTestsInput | TestStatusCreateOrConnectWithoutTestsInput[]
    upsert?: TestStatusUpsertWithWhereUniqueWithoutTestsInput | TestStatusUpsertWithWhereUniqueWithoutTestsInput[]
    createMany?: TestStatusCreateManyTestsInputEnvelope
    set?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    disconnect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    delete?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    connect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    update?: TestStatusUpdateWithWhereUniqueWithoutTestsInput | TestStatusUpdateWithWhereUniqueWithoutTestsInput[]
    updateMany?: TestStatusUpdateManyWithWhereWithoutTestsInput | TestStatusUpdateManyWithWhereWithoutTestsInput[]
    deleteMany?: TestStatusScalarWhereInput | TestStatusScalarWhereInput[]
  }

  export type AnswersUncheckedUpdateManyWithoutTestsNestedInput = {
    create?: XOR<AnswersCreateWithoutTestsInput, AnswersUncheckedCreateWithoutTestsInput> | AnswersCreateWithoutTestsInput[] | AnswersUncheckedCreateWithoutTestsInput[]
    connectOrCreate?: AnswersCreateOrConnectWithoutTestsInput | AnswersCreateOrConnectWithoutTestsInput[]
    upsert?: AnswersUpsertWithWhereUniqueWithoutTestsInput | AnswersUpsertWithWhereUniqueWithoutTestsInput[]
    createMany?: AnswersCreateManyTestsInputEnvelope
    set?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    disconnect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    delete?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    connect?: AnswersWhereUniqueInput | AnswersWhereUniqueInput[]
    update?: AnswersUpdateWithWhereUniqueWithoutTestsInput | AnswersUpdateWithWhereUniqueWithoutTestsInput[]
    updateMany?: AnswersUpdateManyWithWhereWithoutTestsInput | AnswersUpdateManyWithWhereWithoutTestsInput[]
    deleteMany?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
  }

  export type TestStatusUncheckedUpdateManyWithoutTestsNestedInput = {
    create?: XOR<TestStatusCreateWithoutTestsInput, TestStatusUncheckedCreateWithoutTestsInput> | TestStatusCreateWithoutTestsInput[] | TestStatusUncheckedCreateWithoutTestsInput[]
    connectOrCreate?: TestStatusCreateOrConnectWithoutTestsInput | TestStatusCreateOrConnectWithoutTestsInput[]
    upsert?: TestStatusUpsertWithWhereUniqueWithoutTestsInput | TestStatusUpsertWithWhereUniqueWithoutTestsInput[]
    createMany?: TestStatusCreateManyTestsInputEnvelope
    set?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    disconnect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    delete?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    connect?: TestStatusWhereUniqueInput | TestStatusWhereUniqueInput[]
    update?: TestStatusUpdateWithWhereUniqueWithoutTestsInput | TestStatusUpdateWithWhereUniqueWithoutTestsInput[]
    updateMany?: TestStatusUpdateManyWithWhereWithoutTestsInput | TestStatusUpdateManyWithWhereWithoutTestsInput[]
    deleteMany?: TestStatusScalarWhereInput | TestStatusScalarWhereInput[]
  }

  export type StudentsCreateNestedOneWithoutTestStatusInput = {
    create?: XOR<StudentsCreateWithoutTestStatusInput, StudentsUncheckedCreateWithoutTestStatusInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutTestStatusInput
    connect?: StudentsWhereUniqueInput
  }

  export type TestsCreateNestedOneWithoutTestStatusInput = {
    create?: XOR<TestsCreateWithoutTestStatusInput, TestsUncheckedCreateWithoutTestStatusInput>
    connectOrCreate?: TestsCreateOrConnectWithoutTestStatusInput
    connect?: TestsWhereUniqueInput
  }

  export type StudentsUpdateOneRequiredWithoutTestStatusNestedInput = {
    create?: XOR<StudentsCreateWithoutTestStatusInput, StudentsUncheckedCreateWithoutTestStatusInput>
    connectOrCreate?: StudentsCreateOrConnectWithoutTestStatusInput
    upsert?: StudentsUpsertWithoutTestStatusInput
    connect?: StudentsWhereUniqueInput
    update?: XOR<XOR<StudentsUpdateToOneWithWhereWithoutTestStatusInput, StudentsUpdateWithoutTestStatusInput>, StudentsUncheckedUpdateWithoutTestStatusInput>
  }

  export type TestsUpdateOneRequiredWithoutTestStatusNestedInput = {
    create?: XOR<TestsCreateWithoutTestStatusInput, TestsUncheckedCreateWithoutTestStatusInput>
    connectOrCreate?: TestsCreateOrConnectWithoutTestStatusInput
    upsert?: TestsUpsertWithoutTestStatusInput
    connect?: TestsWhereUniqueInput
    update?: XOR<XOR<TestsUpdateToOneWithWhereWithoutTestStatusInput, TestsUpdateWithoutTestStatusInput>, TestsUncheckedUpdateWithoutTestStatusInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TestsCreateWithoutAnswersInput = {
    test_name: string
    test_desc: string
    Courses: CoursesCreateNestedOneWithoutTestsInput
    TestStatus?: TestStatusCreateNestedManyWithoutTestsInput
  }

  export type TestsUncheckedCreateWithoutAnswersInput = {
    test_id?: number
    test_name: string
    test_desc: string
    course_id: number
    TestStatus?: TestStatusUncheckedCreateNestedManyWithoutTestsInput
  }

  export type TestsCreateOrConnectWithoutAnswersInput = {
    where: TestsWhereUniqueInput
    create: XOR<TestsCreateWithoutAnswersInput, TestsUncheckedCreateWithoutAnswersInput>
  }

  export type TestsUpsertWithoutAnswersInput = {
    update: XOR<TestsUpdateWithoutAnswersInput, TestsUncheckedUpdateWithoutAnswersInput>
    create: XOR<TestsCreateWithoutAnswersInput, TestsUncheckedCreateWithoutAnswersInput>
    where?: TestsWhereInput
  }

  export type TestsUpdateToOneWithWhereWithoutAnswersInput = {
    where?: TestsWhereInput
    data: XOR<TestsUpdateWithoutAnswersInput, TestsUncheckedUpdateWithoutAnswersInput>
  }

  export type TestsUpdateWithoutAnswersInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
    Courses?: CoursesUpdateOneRequiredWithoutTestsNestedInput
    TestStatus?: TestStatusUpdateManyWithoutTestsNestedInput
  }

  export type TestsUncheckedUpdateWithoutAnswersInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
    course_id?: IntFieldUpdateOperationsInput | number
    TestStatus?: TestStatusUncheckedUpdateManyWithoutTestsNestedInput
  }

  export type DesciplinesCreateWithoutCoursesInput = {
    descipline_name: string
    Teachers?: TeachersCreateNestedManyWithoutDesciplinesInput
  }

  export type DesciplinesUncheckedCreateWithoutCoursesInput = {
    descipline_name: string
    Teachers?: TeachersUncheckedCreateNestedManyWithoutDesciplinesInput
  }

  export type DesciplinesCreateOrConnectWithoutCoursesInput = {
    where: DesciplinesWhereUniqueInput
    create: XOR<DesciplinesCreateWithoutCoursesInput, DesciplinesUncheckedCreateWithoutCoursesInput>
  }

  export type MaterialsCreateWithoutCoursesInput = {
    material_name: string
    material_ingo?: string | null
  }

  export type MaterialsUncheckedCreateWithoutCoursesInput = {
    material_id?: number
    material_name: string
    material_ingo?: string | null
  }

  export type MaterialsCreateOrConnectWithoutCoursesInput = {
    where: MaterialsWhereUniqueInput
    create: XOR<MaterialsCreateWithoutCoursesInput, MaterialsUncheckedCreateWithoutCoursesInput>
  }

  export type MaterialsCreateManyCoursesInputEnvelope = {
    data: MaterialsCreateManyCoursesInput | MaterialsCreateManyCoursesInput[]
  }

  export type StudentToCourseCreateWithoutCoursesInput = {
    Students: StudentsCreateNestedOneWithoutStudentToCourseInput
  }

  export type StudentToCourseUncheckedCreateWithoutCoursesInput = {
    STC_id?: number
    student_id: number
  }

  export type StudentToCourseCreateOrConnectWithoutCoursesInput = {
    where: StudentToCourseWhereUniqueInput
    create: XOR<StudentToCourseCreateWithoutCoursesInput, StudentToCourseUncheckedCreateWithoutCoursesInput>
  }

  export type StudentToCourseCreateManyCoursesInputEnvelope = {
    data: StudentToCourseCreateManyCoursesInput | StudentToCourseCreateManyCoursesInput[]
  }

  export type TeacherToCourseCreateWithoutCoursesInput = {
    TTC_id: number
    Teachers: TeachersCreateNestedOneWithoutTeacherToCourseInput
  }

  export type TeacherToCourseUncheckedCreateWithoutCoursesInput = {
    TTC_id: number
    teacher_id: number
  }

  export type TeacherToCourseCreateOrConnectWithoutCoursesInput = {
    where: TeacherToCourseWhereUniqueInput
    create: XOR<TeacherToCourseCreateWithoutCoursesInput, TeacherToCourseUncheckedCreateWithoutCoursesInput>
  }

  export type TeacherToCourseCreateManyCoursesInputEnvelope = {
    data: TeacherToCourseCreateManyCoursesInput | TeacherToCourseCreateManyCoursesInput[]
  }

  export type TestsCreateWithoutCoursesInput = {
    test_name: string
    test_desc: string
    Answers?: AnswersCreateNestedManyWithoutTestsInput
    TestStatus?: TestStatusCreateNestedManyWithoutTestsInput
  }

  export type TestsUncheckedCreateWithoutCoursesInput = {
    test_id?: number
    test_name: string
    test_desc: string
    Answers?: AnswersUncheckedCreateNestedManyWithoutTestsInput
    TestStatus?: TestStatusUncheckedCreateNestedManyWithoutTestsInput
  }

  export type TestsCreateOrConnectWithoutCoursesInput = {
    where: TestsWhereUniqueInput
    create: XOR<TestsCreateWithoutCoursesInput, TestsUncheckedCreateWithoutCoursesInput>
  }

  export type TestsCreateManyCoursesInputEnvelope = {
    data: TestsCreateManyCoursesInput | TestsCreateManyCoursesInput[]
  }

  export type DesciplinesUpsertWithoutCoursesInput = {
    update: XOR<DesciplinesUpdateWithoutCoursesInput, DesciplinesUncheckedUpdateWithoutCoursesInput>
    create: XOR<DesciplinesCreateWithoutCoursesInput, DesciplinesUncheckedCreateWithoutCoursesInput>
    where?: DesciplinesWhereInput
  }

  export type DesciplinesUpdateToOneWithWhereWithoutCoursesInput = {
    where?: DesciplinesWhereInput
    data: XOR<DesciplinesUpdateWithoutCoursesInput, DesciplinesUncheckedUpdateWithoutCoursesInput>
  }

  export type DesciplinesUpdateWithoutCoursesInput = {
    descipline_name?: StringFieldUpdateOperationsInput | string
    Teachers?: TeachersUpdateManyWithoutDesciplinesNestedInput
  }

  export type DesciplinesUncheckedUpdateWithoutCoursesInput = {
    descipline_name?: StringFieldUpdateOperationsInput | string
    Teachers?: TeachersUncheckedUpdateManyWithoutDesciplinesNestedInput
  }

  export type MaterialsUpsertWithWhereUniqueWithoutCoursesInput = {
    where: MaterialsWhereUniqueInput
    update: XOR<MaterialsUpdateWithoutCoursesInput, MaterialsUncheckedUpdateWithoutCoursesInput>
    create: XOR<MaterialsCreateWithoutCoursesInput, MaterialsUncheckedCreateWithoutCoursesInput>
  }

  export type MaterialsUpdateWithWhereUniqueWithoutCoursesInput = {
    where: MaterialsWhereUniqueInput
    data: XOR<MaterialsUpdateWithoutCoursesInput, MaterialsUncheckedUpdateWithoutCoursesInput>
  }

  export type MaterialsUpdateManyWithWhereWithoutCoursesInput = {
    where: MaterialsScalarWhereInput
    data: XOR<MaterialsUpdateManyMutationInput, MaterialsUncheckedUpdateManyWithoutCoursesInput>
  }

  export type MaterialsScalarWhereInput = {
    AND?: MaterialsScalarWhereInput | MaterialsScalarWhereInput[]
    OR?: MaterialsScalarWhereInput[]
    NOT?: MaterialsScalarWhereInput | MaterialsScalarWhereInput[]
    material_id?: IntFilter<"Materials"> | number
    material_name?: StringFilter<"Materials"> | string
    course_id?: IntFilter<"Materials"> | number
    material_ingo?: StringNullableFilter<"Materials"> | string | null
  }

  export type StudentToCourseUpsertWithWhereUniqueWithoutCoursesInput = {
    where: StudentToCourseWhereUniqueInput
    update: XOR<StudentToCourseUpdateWithoutCoursesInput, StudentToCourseUncheckedUpdateWithoutCoursesInput>
    create: XOR<StudentToCourseCreateWithoutCoursesInput, StudentToCourseUncheckedCreateWithoutCoursesInput>
  }

  export type StudentToCourseUpdateWithWhereUniqueWithoutCoursesInput = {
    where: StudentToCourseWhereUniqueInput
    data: XOR<StudentToCourseUpdateWithoutCoursesInput, StudentToCourseUncheckedUpdateWithoutCoursesInput>
  }

  export type StudentToCourseUpdateManyWithWhereWithoutCoursesInput = {
    where: StudentToCourseScalarWhereInput
    data: XOR<StudentToCourseUpdateManyMutationInput, StudentToCourseUncheckedUpdateManyWithoutCoursesInput>
  }

  export type StudentToCourseScalarWhereInput = {
    AND?: StudentToCourseScalarWhereInput | StudentToCourseScalarWhereInput[]
    OR?: StudentToCourseScalarWhereInput[]
    NOT?: StudentToCourseScalarWhereInput | StudentToCourseScalarWhereInput[]
    STC_id?: IntFilter<"StudentToCourse"> | number
    course_id?: IntFilter<"StudentToCourse"> | number
    student_id?: IntFilter<"StudentToCourse"> | number
  }

  export type TeacherToCourseUpsertWithWhereUniqueWithoutCoursesInput = {
    where: TeacherToCourseWhereUniqueInput
    update: XOR<TeacherToCourseUpdateWithoutCoursesInput, TeacherToCourseUncheckedUpdateWithoutCoursesInput>
    create: XOR<TeacherToCourseCreateWithoutCoursesInput, TeacherToCourseUncheckedCreateWithoutCoursesInput>
  }

  export type TeacherToCourseUpdateWithWhereUniqueWithoutCoursesInput = {
    where: TeacherToCourseWhereUniqueInput
    data: XOR<TeacherToCourseUpdateWithoutCoursesInput, TeacherToCourseUncheckedUpdateWithoutCoursesInput>
  }

  export type TeacherToCourseUpdateManyWithWhereWithoutCoursesInput = {
    where: TeacherToCourseScalarWhereInput
    data: XOR<TeacherToCourseUpdateManyMutationInput, TeacherToCourseUncheckedUpdateManyWithoutCoursesInput>
  }

  export type TeacherToCourseScalarWhereInput = {
    AND?: TeacherToCourseScalarWhereInput | TeacherToCourseScalarWhereInput[]
    OR?: TeacherToCourseScalarWhereInput[]
    NOT?: TeacherToCourseScalarWhereInput | TeacherToCourseScalarWhereInput[]
    TTC_id?: IntFilter<"TeacherToCourse"> | number
    teacher_id?: IntFilter<"TeacherToCourse"> | number
    course_id?: IntFilter<"TeacherToCourse"> | number
  }

  export type TestsUpsertWithWhereUniqueWithoutCoursesInput = {
    where: TestsWhereUniqueInput
    update: XOR<TestsUpdateWithoutCoursesInput, TestsUncheckedUpdateWithoutCoursesInput>
    create: XOR<TestsCreateWithoutCoursesInput, TestsUncheckedCreateWithoutCoursesInput>
  }

  export type TestsUpdateWithWhereUniqueWithoutCoursesInput = {
    where: TestsWhereUniqueInput
    data: XOR<TestsUpdateWithoutCoursesInput, TestsUncheckedUpdateWithoutCoursesInput>
  }

  export type TestsUpdateManyWithWhereWithoutCoursesInput = {
    where: TestsScalarWhereInput
    data: XOR<TestsUpdateManyMutationInput, TestsUncheckedUpdateManyWithoutCoursesInput>
  }

  export type TestsScalarWhereInput = {
    AND?: TestsScalarWhereInput | TestsScalarWhereInput[]
    OR?: TestsScalarWhereInput[]
    NOT?: TestsScalarWhereInput | TestsScalarWhereInput[]
    test_id?: IntFilter<"Tests"> | number
    test_name?: StringFilter<"Tests"> | string
    test_desc?: StringFilter<"Tests"> | string
    course_id?: IntFilter<"Tests"> | number
  }

  export type CoursesCreateWithoutDesciplinesInput = {
    course_name: string
    course_cost: number
    course_description?: string | null
    Materials?: MaterialsCreateNestedManyWithoutCoursesInput
    StudentToCourse?: StudentToCourseCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseCreateNestedManyWithoutCoursesInput
    Tests?: TestsCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutDesciplinesInput = {
    course_id?: number
    course_name: string
    course_cost: number
    course_description?: string | null
    Materials?: MaterialsUncheckedCreateNestedManyWithoutCoursesInput
    StudentToCourse?: StudentToCourseUncheckedCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseUncheckedCreateNestedManyWithoutCoursesInput
    Tests?: TestsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutDesciplinesInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutDesciplinesInput, CoursesUncheckedCreateWithoutDesciplinesInput>
  }

  export type CoursesCreateManyDesciplinesInputEnvelope = {
    data: CoursesCreateManyDesciplinesInput | CoursesCreateManyDesciplinesInput[]
  }

  export type TeachersCreateWithoutDesciplinesInput = {
    fio: string
    email: string
    user_password: string
    TeacherToCourse?: TeacherToCourseCreateNestedManyWithoutTeachersInput
  }

  export type TeachersUncheckedCreateWithoutDesciplinesInput = {
    user_ident?: number
    fio: string
    email: string
    user_password: string
    TeacherToCourse?: TeacherToCourseUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type TeachersCreateOrConnectWithoutDesciplinesInput = {
    where: TeachersWhereUniqueInput
    create: XOR<TeachersCreateWithoutDesciplinesInput, TeachersUncheckedCreateWithoutDesciplinesInput>
  }

  export type TeachersCreateManyDesciplinesInputEnvelope = {
    data: TeachersCreateManyDesciplinesInput | TeachersCreateManyDesciplinesInput[]
  }

  export type CoursesUpsertWithWhereUniqueWithoutDesciplinesInput = {
    where: CoursesWhereUniqueInput
    update: XOR<CoursesUpdateWithoutDesciplinesInput, CoursesUncheckedUpdateWithoutDesciplinesInput>
    create: XOR<CoursesCreateWithoutDesciplinesInput, CoursesUncheckedCreateWithoutDesciplinesInput>
  }

  export type CoursesUpdateWithWhereUniqueWithoutDesciplinesInput = {
    where: CoursesWhereUniqueInput
    data: XOR<CoursesUpdateWithoutDesciplinesInput, CoursesUncheckedUpdateWithoutDesciplinesInput>
  }

  export type CoursesUpdateManyWithWhereWithoutDesciplinesInput = {
    where: CoursesScalarWhereInput
    data: XOR<CoursesUpdateManyMutationInput, CoursesUncheckedUpdateManyWithoutDesciplinesInput>
  }

  export type CoursesScalarWhereInput = {
    AND?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
    OR?: CoursesScalarWhereInput[]
    NOT?: CoursesScalarWhereInput | CoursesScalarWhereInput[]
    course_id?: IntFilter<"Courses"> | number
    course_name?: StringFilter<"Courses"> | string
    course_cost?: IntFilter<"Courses"> | number
    course_description?: StringNullableFilter<"Courses"> | string | null
    course_descipline?: StringFilter<"Courses"> | string
  }

  export type TeachersUpsertWithWhereUniqueWithoutDesciplinesInput = {
    where: TeachersWhereUniqueInput
    update: XOR<TeachersUpdateWithoutDesciplinesInput, TeachersUncheckedUpdateWithoutDesciplinesInput>
    create: XOR<TeachersCreateWithoutDesciplinesInput, TeachersUncheckedCreateWithoutDesciplinesInput>
  }

  export type TeachersUpdateWithWhereUniqueWithoutDesciplinesInput = {
    where: TeachersWhereUniqueInput
    data: XOR<TeachersUpdateWithoutDesciplinesInput, TeachersUncheckedUpdateWithoutDesciplinesInput>
  }

  export type TeachersUpdateManyWithWhereWithoutDesciplinesInput = {
    where: TeachersScalarWhereInput
    data: XOR<TeachersUpdateManyMutationInput, TeachersUncheckedUpdateManyWithoutDesciplinesInput>
  }

  export type TeachersScalarWhereInput = {
    AND?: TeachersScalarWhereInput | TeachersScalarWhereInput[]
    OR?: TeachersScalarWhereInput[]
    NOT?: TeachersScalarWhereInput | TeachersScalarWhereInput[]
    user_ident?: IntFilter<"Teachers"> | number
    fio?: StringFilter<"Teachers"> | string
    email?: StringFilter<"Teachers"> | string
    user_password?: StringFilter<"Teachers"> | string
    descipline?: StringFilter<"Teachers"> | string
  }

  export type CoursesCreateWithoutMaterialsInput = {
    course_name: string
    course_cost: number
    course_description?: string | null
    Desciplines: DesciplinesCreateNestedOneWithoutCoursesInput
    StudentToCourse?: StudentToCourseCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseCreateNestedManyWithoutCoursesInput
    Tests?: TestsCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutMaterialsInput = {
    course_id?: number
    course_name: string
    course_cost: number
    course_description?: string | null
    course_descipline: string
    StudentToCourse?: StudentToCourseUncheckedCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseUncheckedCreateNestedManyWithoutCoursesInput
    Tests?: TestsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutMaterialsInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutMaterialsInput, CoursesUncheckedCreateWithoutMaterialsInput>
  }

  export type CoursesUpsertWithoutMaterialsInput = {
    update: XOR<CoursesUpdateWithoutMaterialsInput, CoursesUncheckedUpdateWithoutMaterialsInput>
    create: XOR<CoursesCreateWithoutMaterialsInput, CoursesUncheckedCreateWithoutMaterialsInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutMaterialsInput, CoursesUncheckedUpdateWithoutMaterialsInput>
  }

  export type CoursesUpdateWithoutMaterialsInput = {
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    Desciplines?: DesciplinesUpdateOneRequiredWithoutCoursesNestedInput
    StudentToCourse?: StudentToCourseUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutMaterialsInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    course_descipline?: StringFieldUpdateOperationsInput | string
    StudentToCourse?: StudentToCourseUncheckedUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUncheckedUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type StudentToCourseCreateWithoutStudentsInput = {
    Courses: CoursesCreateNestedOneWithoutStudentToCourseInput
  }

  export type StudentToCourseUncheckedCreateWithoutStudentsInput = {
    STC_id?: number
    course_id: number
  }

  export type StudentToCourseCreateOrConnectWithoutStudentsInput = {
    where: StudentToCourseWhereUniqueInput
    create: XOR<StudentToCourseCreateWithoutStudentsInput, StudentToCourseUncheckedCreateWithoutStudentsInput>
  }

  export type StudentToCourseCreateManyStudentsInputEnvelope = {
    data: StudentToCourseCreateManyStudentsInput | StudentToCourseCreateManyStudentsInput[]
  }

  export type TestStatusCreateWithoutStudentsInput = {
    Tests: TestsCreateNestedOneWithoutTestStatusInput
  }

  export type TestStatusUncheckedCreateWithoutStudentsInput = {
    status_id?: number
    test_id: number
  }

  export type TestStatusCreateOrConnectWithoutStudentsInput = {
    where: TestStatusWhereUniqueInput
    create: XOR<TestStatusCreateWithoutStudentsInput, TestStatusUncheckedCreateWithoutStudentsInput>
  }

  export type TestStatusCreateManyStudentsInputEnvelope = {
    data: TestStatusCreateManyStudentsInput | TestStatusCreateManyStudentsInput[]
  }

  export type StudentToCourseUpsertWithWhereUniqueWithoutStudentsInput = {
    where: StudentToCourseWhereUniqueInput
    update: XOR<StudentToCourseUpdateWithoutStudentsInput, StudentToCourseUncheckedUpdateWithoutStudentsInput>
    create: XOR<StudentToCourseCreateWithoutStudentsInput, StudentToCourseUncheckedCreateWithoutStudentsInput>
  }

  export type StudentToCourseUpdateWithWhereUniqueWithoutStudentsInput = {
    where: StudentToCourseWhereUniqueInput
    data: XOR<StudentToCourseUpdateWithoutStudentsInput, StudentToCourseUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentToCourseUpdateManyWithWhereWithoutStudentsInput = {
    where: StudentToCourseScalarWhereInput
    data: XOR<StudentToCourseUpdateManyMutationInput, StudentToCourseUncheckedUpdateManyWithoutStudentsInput>
  }

  export type TestStatusUpsertWithWhereUniqueWithoutStudentsInput = {
    where: TestStatusWhereUniqueInput
    update: XOR<TestStatusUpdateWithoutStudentsInput, TestStatusUncheckedUpdateWithoutStudentsInput>
    create: XOR<TestStatusCreateWithoutStudentsInput, TestStatusUncheckedCreateWithoutStudentsInput>
  }

  export type TestStatusUpdateWithWhereUniqueWithoutStudentsInput = {
    where: TestStatusWhereUniqueInput
    data: XOR<TestStatusUpdateWithoutStudentsInput, TestStatusUncheckedUpdateWithoutStudentsInput>
  }

  export type TestStatusUpdateManyWithWhereWithoutStudentsInput = {
    where: TestStatusScalarWhereInput
    data: XOR<TestStatusUpdateManyMutationInput, TestStatusUncheckedUpdateManyWithoutStudentsInput>
  }

  export type TestStatusScalarWhereInput = {
    AND?: TestStatusScalarWhereInput | TestStatusScalarWhereInput[]
    OR?: TestStatusScalarWhereInput[]
    NOT?: TestStatusScalarWhereInput | TestStatusScalarWhereInput[]
    status_id?: IntFilter<"TestStatus"> | number
    test_id?: IntFilter<"TestStatus"> | number
    student_id?: IntFilter<"TestStatus"> | number
  }

  export type CoursesCreateWithoutStudentToCourseInput = {
    course_name: string
    course_cost: number
    course_description?: string | null
    Desciplines: DesciplinesCreateNestedOneWithoutCoursesInput
    Materials?: MaterialsCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseCreateNestedManyWithoutCoursesInput
    Tests?: TestsCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutStudentToCourseInput = {
    course_id?: number
    course_name: string
    course_cost: number
    course_description?: string | null
    course_descipline: string
    Materials?: MaterialsUncheckedCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseUncheckedCreateNestedManyWithoutCoursesInput
    Tests?: TestsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutStudentToCourseInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutStudentToCourseInput, CoursesUncheckedCreateWithoutStudentToCourseInput>
  }

  export type StudentsCreateWithoutStudentToCourseInput = {
    fio: string
    balance?: number | null
    email: string
    user_password: string
    TestStatus?: TestStatusCreateNestedManyWithoutStudentsInput
  }

  export type StudentsUncheckedCreateWithoutStudentToCourseInput = {
    user_ident?: number
    fio: string
    balance?: number | null
    email: string
    user_password: string
    TestStatus?: TestStatusUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type StudentsCreateOrConnectWithoutStudentToCourseInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutStudentToCourseInput, StudentsUncheckedCreateWithoutStudentToCourseInput>
  }

  export type CoursesUpsertWithoutStudentToCourseInput = {
    update: XOR<CoursesUpdateWithoutStudentToCourseInput, CoursesUncheckedUpdateWithoutStudentToCourseInput>
    create: XOR<CoursesCreateWithoutStudentToCourseInput, CoursesUncheckedCreateWithoutStudentToCourseInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutStudentToCourseInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutStudentToCourseInput, CoursesUncheckedUpdateWithoutStudentToCourseInput>
  }

  export type CoursesUpdateWithoutStudentToCourseInput = {
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    Desciplines?: DesciplinesUpdateOneRequiredWithoutCoursesNestedInput
    Materials?: MaterialsUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutStudentToCourseInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    course_descipline?: StringFieldUpdateOperationsInput | string
    Materials?: MaterialsUncheckedUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUncheckedUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type StudentsUpsertWithoutStudentToCourseInput = {
    update: XOR<StudentsUpdateWithoutStudentToCourseInput, StudentsUncheckedUpdateWithoutStudentToCourseInput>
    create: XOR<StudentsCreateWithoutStudentToCourseInput, StudentsUncheckedCreateWithoutStudentToCourseInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutStudentToCourseInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutStudentToCourseInput, StudentsUncheckedUpdateWithoutStudentToCourseInput>
  }

  export type StudentsUpdateWithoutStudentToCourseInput = {
    fio?: StringFieldUpdateOperationsInput | string
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    TestStatus?: TestStatusUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsUncheckedUpdateWithoutStudentToCourseInput = {
    user_ident?: IntFieldUpdateOperationsInput | number
    fio?: StringFieldUpdateOperationsInput | string
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    TestStatus?: TestStatusUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type DesciplinesCreateWithoutTeachersInput = {
    descipline_name: string
    Courses?: CoursesCreateNestedManyWithoutDesciplinesInput
  }

  export type DesciplinesUncheckedCreateWithoutTeachersInput = {
    descipline_name: string
    Courses?: CoursesUncheckedCreateNestedManyWithoutDesciplinesInput
  }

  export type DesciplinesCreateOrConnectWithoutTeachersInput = {
    where: DesciplinesWhereUniqueInput
    create: XOR<DesciplinesCreateWithoutTeachersInput, DesciplinesUncheckedCreateWithoutTeachersInput>
  }

  export type TeacherToCourseCreateWithoutTeachersInput = {
    TTC_id: number
    Courses: CoursesCreateNestedOneWithoutTeacherToCourseInput
  }

  export type TeacherToCourseUncheckedCreateWithoutTeachersInput = {
    TTC_id: number
    course_id: number
  }

  export type TeacherToCourseCreateOrConnectWithoutTeachersInput = {
    where: TeacherToCourseWhereUniqueInput
    create: XOR<TeacherToCourseCreateWithoutTeachersInput, TeacherToCourseUncheckedCreateWithoutTeachersInput>
  }

  export type TeacherToCourseCreateManyTeachersInputEnvelope = {
    data: TeacherToCourseCreateManyTeachersInput | TeacherToCourseCreateManyTeachersInput[]
  }

  export type DesciplinesUpsertWithoutTeachersInput = {
    update: XOR<DesciplinesUpdateWithoutTeachersInput, DesciplinesUncheckedUpdateWithoutTeachersInput>
    create: XOR<DesciplinesCreateWithoutTeachersInput, DesciplinesUncheckedCreateWithoutTeachersInput>
    where?: DesciplinesWhereInput
  }

  export type DesciplinesUpdateToOneWithWhereWithoutTeachersInput = {
    where?: DesciplinesWhereInput
    data: XOR<DesciplinesUpdateWithoutTeachersInput, DesciplinesUncheckedUpdateWithoutTeachersInput>
  }

  export type DesciplinesUpdateWithoutTeachersInput = {
    descipline_name?: StringFieldUpdateOperationsInput | string
    Courses?: CoursesUpdateManyWithoutDesciplinesNestedInput
  }

  export type DesciplinesUncheckedUpdateWithoutTeachersInput = {
    descipline_name?: StringFieldUpdateOperationsInput | string
    Courses?: CoursesUncheckedUpdateManyWithoutDesciplinesNestedInput
  }

  export type TeacherToCourseUpsertWithWhereUniqueWithoutTeachersInput = {
    where: TeacherToCourseWhereUniqueInput
    update: XOR<TeacherToCourseUpdateWithoutTeachersInput, TeacherToCourseUncheckedUpdateWithoutTeachersInput>
    create: XOR<TeacherToCourseCreateWithoutTeachersInput, TeacherToCourseUncheckedCreateWithoutTeachersInput>
  }

  export type TeacherToCourseUpdateWithWhereUniqueWithoutTeachersInput = {
    where: TeacherToCourseWhereUniqueInput
    data: XOR<TeacherToCourseUpdateWithoutTeachersInput, TeacherToCourseUncheckedUpdateWithoutTeachersInput>
  }

  export type TeacherToCourseUpdateManyWithWhereWithoutTeachersInput = {
    where: TeacherToCourseScalarWhereInput
    data: XOR<TeacherToCourseUpdateManyMutationInput, TeacherToCourseUncheckedUpdateManyWithoutTeachersInput>
  }

  export type CoursesCreateWithoutTeacherToCourseInput = {
    course_name: string
    course_cost: number
    course_description?: string | null
    Desciplines: DesciplinesCreateNestedOneWithoutCoursesInput
    Materials?: MaterialsCreateNestedManyWithoutCoursesInput
    StudentToCourse?: StudentToCourseCreateNestedManyWithoutCoursesInput
    Tests?: TestsCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutTeacherToCourseInput = {
    course_id?: number
    course_name: string
    course_cost: number
    course_description?: string | null
    course_descipline: string
    Materials?: MaterialsUncheckedCreateNestedManyWithoutCoursesInput
    StudentToCourse?: StudentToCourseUncheckedCreateNestedManyWithoutCoursesInput
    Tests?: TestsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutTeacherToCourseInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutTeacherToCourseInput, CoursesUncheckedCreateWithoutTeacherToCourseInput>
  }

  export type TeachersCreateWithoutTeacherToCourseInput = {
    fio: string
    email: string
    user_password: string
    Desciplines: DesciplinesCreateNestedOneWithoutTeachersInput
  }

  export type TeachersUncheckedCreateWithoutTeacherToCourseInput = {
    user_ident?: number
    fio: string
    email: string
    user_password: string
    descipline: string
  }

  export type TeachersCreateOrConnectWithoutTeacherToCourseInput = {
    where: TeachersWhereUniqueInput
    create: XOR<TeachersCreateWithoutTeacherToCourseInput, TeachersUncheckedCreateWithoutTeacherToCourseInput>
  }

  export type CoursesUpsertWithoutTeacherToCourseInput = {
    update: XOR<CoursesUpdateWithoutTeacherToCourseInput, CoursesUncheckedUpdateWithoutTeacherToCourseInput>
    create: XOR<CoursesCreateWithoutTeacherToCourseInput, CoursesUncheckedCreateWithoutTeacherToCourseInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutTeacherToCourseInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutTeacherToCourseInput, CoursesUncheckedUpdateWithoutTeacherToCourseInput>
  }

  export type CoursesUpdateWithoutTeacherToCourseInput = {
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    Desciplines?: DesciplinesUpdateOneRequiredWithoutCoursesNestedInput
    Materials?: MaterialsUpdateManyWithoutCoursesNestedInput
    StudentToCourse?: StudentToCourseUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutTeacherToCourseInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    course_descipline?: StringFieldUpdateOperationsInput | string
    Materials?: MaterialsUncheckedUpdateManyWithoutCoursesNestedInput
    StudentToCourse?: StudentToCourseUncheckedUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type TeachersUpsertWithoutTeacherToCourseInput = {
    update: XOR<TeachersUpdateWithoutTeacherToCourseInput, TeachersUncheckedUpdateWithoutTeacherToCourseInput>
    create: XOR<TeachersCreateWithoutTeacherToCourseInput, TeachersUncheckedCreateWithoutTeacherToCourseInput>
    where?: TeachersWhereInput
  }

  export type TeachersUpdateToOneWithWhereWithoutTeacherToCourseInput = {
    where?: TeachersWhereInput
    data: XOR<TeachersUpdateWithoutTeacherToCourseInput, TeachersUncheckedUpdateWithoutTeacherToCourseInput>
  }

  export type TeachersUpdateWithoutTeacherToCourseInput = {
    fio?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    Desciplines?: DesciplinesUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeachersUncheckedUpdateWithoutTeacherToCourseInput = {
    user_ident?: IntFieldUpdateOperationsInput | number
    fio?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    descipline?: StringFieldUpdateOperationsInput | string
  }

  export type AnswersCreateWithoutTestsInput = {
    answer_id: number
    question: string
    answers: string
    answer_count: number
    answer_right: number
  }

  export type AnswersUncheckedCreateWithoutTestsInput = {
    answer_id: number
    question: string
    answers: string
    answer_count: number
    answer_right: number
  }

  export type AnswersCreateOrConnectWithoutTestsInput = {
    where: AnswersWhereUniqueInput
    create: XOR<AnswersCreateWithoutTestsInput, AnswersUncheckedCreateWithoutTestsInput>
  }

  export type AnswersCreateManyTestsInputEnvelope = {
    data: AnswersCreateManyTestsInput | AnswersCreateManyTestsInput[]
  }

  export type CoursesCreateWithoutTestsInput = {
    course_name: string
    course_cost: number
    course_description?: string | null
    Desciplines: DesciplinesCreateNestedOneWithoutCoursesInput
    Materials?: MaterialsCreateNestedManyWithoutCoursesInput
    StudentToCourse?: StudentToCourseCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseCreateNestedManyWithoutCoursesInput
  }

  export type CoursesUncheckedCreateWithoutTestsInput = {
    course_id?: number
    course_name: string
    course_cost: number
    course_description?: string | null
    course_descipline: string
    Materials?: MaterialsUncheckedCreateNestedManyWithoutCoursesInput
    StudentToCourse?: StudentToCourseUncheckedCreateNestedManyWithoutCoursesInput
    TeacherToCourse?: TeacherToCourseUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CoursesCreateOrConnectWithoutTestsInput = {
    where: CoursesWhereUniqueInput
    create: XOR<CoursesCreateWithoutTestsInput, CoursesUncheckedCreateWithoutTestsInput>
  }

  export type TestStatusCreateWithoutTestsInput = {
    Students: StudentsCreateNestedOneWithoutTestStatusInput
  }

  export type TestStatusUncheckedCreateWithoutTestsInput = {
    status_id?: number
    student_id: number
  }

  export type TestStatusCreateOrConnectWithoutTestsInput = {
    where: TestStatusWhereUniqueInput
    create: XOR<TestStatusCreateWithoutTestsInput, TestStatusUncheckedCreateWithoutTestsInput>
  }

  export type TestStatusCreateManyTestsInputEnvelope = {
    data: TestStatusCreateManyTestsInput | TestStatusCreateManyTestsInput[]
  }

  export type AnswersUpsertWithWhereUniqueWithoutTestsInput = {
    where: AnswersWhereUniqueInput
    update: XOR<AnswersUpdateWithoutTestsInput, AnswersUncheckedUpdateWithoutTestsInput>
    create: XOR<AnswersCreateWithoutTestsInput, AnswersUncheckedCreateWithoutTestsInput>
  }

  export type AnswersUpdateWithWhereUniqueWithoutTestsInput = {
    where: AnswersWhereUniqueInput
    data: XOR<AnswersUpdateWithoutTestsInput, AnswersUncheckedUpdateWithoutTestsInput>
  }

  export type AnswersUpdateManyWithWhereWithoutTestsInput = {
    where: AnswersScalarWhereInput
    data: XOR<AnswersUpdateManyMutationInput, AnswersUncheckedUpdateManyWithoutTestsInput>
  }

  export type AnswersScalarWhereInput = {
    AND?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
    OR?: AnswersScalarWhereInput[]
    NOT?: AnswersScalarWhereInput | AnswersScalarWhereInput[]
    answer_id?: IntFilter<"Answers"> | number
    question?: StringFilter<"Answers"> | string
    answers?: StringFilter<"Answers"> | string
    answer_count?: IntFilter<"Answers"> | number
    answer_right?: IntFilter<"Answers"> | number
    test_id?: IntFilter<"Answers"> | number
  }

  export type CoursesUpsertWithoutTestsInput = {
    update: XOR<CoursesUpdateWithoutTestsInput, CoursesUncheckedUpdateWithoutTestsInput>
    create: XOR<CoursesCreateWithoutTestsInput, CoursesUncheckedCreateWithoutTestsInput>
    where?: CoursesWhereInput
  }

  export type CoursesUpdateToOneWithWhereWithoutTestsInput = {
    where?: CoursesWhereInput
    data: XOR<CoursesUpdateWithoutTestsInput, CoursesUncheckedUpdateWithoutTestsInput>
  }

  export type CoursesUpdateWithoutTestsInput = {
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    Desciplines?: DesciplinesUpdateOneRequiredWithoutCoursesNestedInput
    Materials?: MaterialsUpdateManyWithoutCoursesNestedInput
    StudentToCourse?: StudentToCourseUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutTestsInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    course_descipline?: StringFieldUpdateOperationsInput | string
    Materials?: MaterialsUncheckedUpdateManyWithoutCoursesNestedInput
    StudentToCourse?: StudentToCourseUncheckedUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type TestStatusUpsertWithWhereUniqueWithoutTestsInput = {
    where: TestStatusWhereUniqueInput
    update: XOR<TestStatusUpdateWithoutTestsInput, TestStatusUncheckedUpdateWithoutTestsInput>
    create: XOR<TestStatusCreateWithoutTestsInput, TestStatusUncheckedCreateWithoutTestsInput>
  }

  export type TestStatusUpdateWithWhereUniqueWithoutTestsInput = {
    where: TestStatusWhereUniqueInput
    data: XOR<TestStatusUpdateWithoutTestsInput, TestStatusUncheckedUpdateWithoutTestsInput>
  }

  export type TestStatusUpdateManyWithWhereWithoutTestsInput = {
    where: TestStatusScalarWhereInput
    data: XOR<TestStatusUpdateManyMutationInput, TestStatusUncheckedUpdateManyWithoutTestsInput>
  }

  export type StudentsCreateWithoutTestStatusInput = {
    fio: string
    balance?: number | null
    email: string
    user_password: string
    StudentToCourse?: StudentToCourseCreateNestedManyWithoutStudentsInput
  }

  export type StudentsUncheckedCreateWithoutTestStatusInput = {
    user_ident?: number
    fio: string
    balance?: number | null
    email: string
    user_password: string
    StudentToCourse?: StudentToCourseUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type StudentsCreateOrConnectWithoutTestStatusInput = {
    where: StudentsWhereUniqueInput
    create: XOR<StudentsCreateWithoutTestStatusInput, StudentsUncheckedCreateWithoutTestStatusInput>
  }

  export type TestsCreateWithoutTestStatusInput = {
    test_name: string
    test_desc: string
    Answers?: AnswersCreateNestedManyWithoutTestsInput
    Courses: CoursesCreateNestedOneWithoutTestsInput
  }

  export type TestsUncheckedCreateWithoutTestStatusInput = {
    test_id?: number
    test_name: string
    test_desc: string
    course_id: number
    Answers?: AnswersUncheckedCreateNestedManyWithoutTestsInput
  }

  export type TestsCreateOrConnectWithoutTestStatusInput = {
    where: TestsWhereUniqueInput
    create: XOR<TestsCreateWithoutTestStatusInput, TestsUncheckedCreateWithoutTestStatusInput>
  }

  export type StudentsUpsertWithoutTestStatusInput = {
    update: XOR<StudentsUpdateWithoutTestStatusInput, StudentsUncheckedUpdateWithoutTestStatusInput>
    create: XOR<StudentsCreateWithoutTestStatusInput, StudentsUncheckedCreateWithoutTestStatusInput>
    where?: StudentsWhereInput
  }

  export type StudentsUpdateToOneWithWhereWithoutTestStatusInput = {
    where?: StudentsWhereInput
    data: XOR<StudentsUpdateWithoutTestStatusInput, StudentsUncheckedUpdateWithoutTestStatusInput>
  }

  export type StudentsUpdateWithoutTestStatusInput = {
    fio?: StringFieldUpdateOperationsInput | string
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    StudentToCourse?: StudentToCourseUpdateManyWithoutStudentsNestedInput
  }

  export type StudentsUncheckedUpdateWithoutTestStatusInput = {
    user_ident?: IntFieldUpdateOperationsInput | number
    fio?: StringFieldUpdateOperationsInput | string
    balance?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    StudentToCourse?: StudentToCourseUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type TestsUpsertWithoutTestStatusInput = {
    update: XOR<TestsUpdateWithoutTestStatusInput, TestsUncheckedUpdateWithoutTestStatusInput>
    create: XOR<TestsCreateWithoutTestStatusInput, TestsUncheckedCreateWithoutTestStatusInput>
    where?: TestsWhereInput
  }

  export type TestsUpdateToOneWithWhereWithoutTestStatusInput = {
    where?: TestsWhereInput
    data: XOR<TestsUpdateWithoutTestStatusInput, TestsUncheckedUpdateWithoutTestStatusInput>
  }

  export type TestsUpdateWithoutTestStatusInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
    Answers?: AnswersUpdateManyWithoutTestsNestedInput
    Courses?: CoursesUpdateOneRequiredWithoutTestsNestedInput
  }

  export type TestsUncheckedUpdateWithoutTestStatusInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
    course_id?: IntFieldUpdateOperationsInput | number
    Answers?: AnswersUncheckedUpdateManyWithoutTestsNestedInput
  }

  export type MaterialsCreateManyCoursesInput = {
    material_name: string
    material_ingo?: string | null
  }

  export type StudentToCourseCreateManyCoursesInput = {
    student_id: number
  }

  export type TeacherToCourseCreateManyCoursesInput = {
    TTC_id: number
    teacher_id: number
  }

  export type TestsCreateManyCoursesInput = {
    test_name: string
    test_desc: string
  }

  export type MaterialsUpdateWithoutCoursesInput = {
    material_name?: StringFieldUpdateOperationsInput | string
    material_ingo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialsUncheckedUpdateWithoutCoursesInput = {
    material_id?: IntFieldUpdateOperationsInput | number
    material_name?: StringFieldUpdateOperationsInput | string
    material_ingo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialsUncheckedUpdateManyWithoutCoursesInput = {
    material_id?: IntFieldUpdateOperationsInput | number
    material_name?: StringFieldUpdateOperationsInput | string
    material_ingo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentToCourseUpdateWithoutCoursesInput = {
    Students?: StudentsUpdateOneRequiredWithoutStudentToCourseNestedInput
  }

  export type StudentToCourseUncheckedUpdateWithoutCoursesInput = {
    STC_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
  }

  export type StudentToCourseUncheckedUpdateManyWithoutCoursesInput = {
    STC_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherToCourseUpdateWithoutCoursesInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
    Teachers?: TeachersUpdateOneRequiredWithoutTeacherToCourseNestedInput
  }

  export type TeacherToCourseUncheckedUpdateWithoutCoursesInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherToCourseUncheckedUpdateManyWithoutCoursesInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
  }

  export type TestsUpdateWithoutCoursesInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
    Answers?: AnswersUpdateManyWithoutTestsNestedInput
    TestStatus?: TestStatusUpdateManyWithoutTestsNestedInput
  }

  export type TestsUncheckedUpdateWithoutCoursesInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
    Answers?: AnswersUncheckedUpdateManyWithoutTestsNestedInput
    TestStatus?: TestStatusUncheckedUpdateManyWithoutTestsNestedInput
  }

  export type TestsUncheckedUpdateManyWithoutCoursesInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_desc?: StringFieldUpdateOperationsInput | string
  }

  export type CoursesCreateManyDesciplinesInput = {
    course_name: string
    course_cost: number
    course_description?: string | null
  }

  export type TeachersCreateManyDesciplinesInput = {
    fio: string
    email: string
    user_password: string
  }

  export type CoursesUpdateWithoutDesciplinesInput = {
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    Materials?: MaterialsUpdateManyWithoutCoursesNestedInput
    StudentToCourse?: StudentToCourseUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateWithoutDesciplinesInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
    Materials?: MaterialsUncheckedUpdateManyWithoutCoursesNestedInput
    StudentToCourse?: StudentToCourseUncheckedUpdateManyWithoutCoursesNestedInput
    TeacherToCourse?: TeacherToCourseUncheckedUpdateManyWithoutCoursesNestedInput
    Tests?: TestsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CoursesUncheckedUpdateManyWithoutDesciplinesInput = {
    course_id?: IntFieldUpdateOperationsInput | number
    course_name?: StringFieldUpdateOperationsInput | string
    course_cost?: IntFieldUpdateOperationsInput | number
    course_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeachersUpdateWithoutDesciplinesInput = {
    fio?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    TeacherToCourse?: TeacherToCourseUpdateManyWithoutTeachersNestedInput
  }

  export type TeachersUncheckedUpdateWithoutDesciplinesInput = {
    user_ident?: IntFieldUpdateOperationsInput | number
    fio?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    TeacherToCourse?: TeacherToCourseUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type TeachersUncheckedUpdateManyWithoutDesciplinesInput = {
    user_ident?: IntFieldUpdateOperationsInput | number
    fio?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
  }

  export type StudentToCourseCreateManyStudentsInput = {
    course_id: number
  }

  export type TestStatusCreateManyStudentsInput = {
    test_id: number
  }

  export type StudentToCourseUpdateWithoutStudentsInput = {
    Courses?: CoursesUpdateOneRequiredWithoutStudentToCourseNestedInput
  }

  export type StudentToCourseUncheckedUpdateWithoutStudentsInput = {
    STC_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type StudentToCourseUncheckedUpdateManyWithoutStudentsInput = {
    STC_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type TestStatusUpdateWithoutStudentsInput = {
    Tests?: TestsUpdateOneRequiredWithoutTestStatusNestedInput
  }

  export type TestStatusUncheckedUpdateWithoutStudentsInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
  }

  export type TestStatusUncheckedUpdateManyWithoutStudentsInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    test_id?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherToCourseCreateManyTeachersInput = {
    TTC_id: number
    course_id: number
  }

  export type TeacherToCourseUpdateWithoutTeachersInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
    Courses?: CoursesUpdateOneRequiredWithoutTeacherToCourseNestedInput
  }

  export type TeacherToCourseUncheckedUpdateWithoutTeachersInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type TeacherToCourseUncheckedUpdateManyWithoutTeachersInput = {
    TTC_id?: IntFieldUpdateOperationsInput | number
    course_id?: IntFieldUpdateOperationsInput | number
  }

  export type AnswersCreateManyTestsInput = {
    answer_id: number
    question: string
    answers: string
    answer_count: number
    answer_right: number
  }

  export type TestStatusCreateManyTestsInput = {
    student_id: number
  }

  export type AnswersUpdateWithoutTestsInput = {
    answer_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answers?: StringFieldUpdateOperationsInput | string
    answer_count?: IntFieldUpdateOperationsInput | number
    answer_right?: IntFieldUpdateOperationsInput | number
  }

  export type AnswersUncheckedUpdateWithoutTestsInput = {
    answer_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answers?: StringFieldUpdateOperationsInput | string
    answer_count?: IntFieldUpdateOperationsInput | number
    answer_right?: IntFieldUpdateOperationsInput | number
  }

  export type AnswersUncheckedUpdateManyWithoutTestsInput = {
    answer_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answers?: StringFieldUpdateOperationsInput | string
    answer_count?: IntFieldUpdateOperationsInput | number
    answer_right?: IntFieldUpdateOperationsInput | number
  }

  export type TestStatusUpdateWithoutTestsInput = {
    Students?: StudentsUpdateOneRequiredWithoutTestStatusNestedInput
  }

  export type TestStatusUncheckedUpdateWithoutTestsInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
  }

  export type TestStatusUncheckedUpdateManyWithoutTestsInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CoursesCountOutputTypeDefaultArgs instead
     */
    export type CoursesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DesciplinesCountOutputTypeDefaultArgs instead
     */
    export type DesciplinesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DesciplinesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentsCountOutputTypeDefaultArgs instead
     */
    export type StudentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeachersCountOutputTypeDefaultArgs instead
     */
    export type TeachersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeachersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestsCountOutputTypeDefaultArgs instead
     */
    export type TestsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnswersDefaultArgs instead
     */
    export type AnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnswersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoursesDefaultArgs instead
     */
    export type CoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DesciplinesDefaultArgs instead
     */
    export type DesciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DesciplinesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialsDefaultArgs instead
     */
    export type MaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentsDefaultArgs instead
     */
    export type StudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentToCourseDefaultArgs instead
     */
    export type StudentToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentToCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeachersDefaultArgs instead
     */
    export type TeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeachersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherToCourseDefaultArgs instead
     */
    export type TeacherToCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherToCourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestsDefaultArgs instead
     */
    export type TestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TestStatusDefaultArgs instead
     */
    export type TestStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TestStatusDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}